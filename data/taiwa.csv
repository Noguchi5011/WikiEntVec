ID,例文,質問内容,解答,,,,,,,,,,,
1,"printfで文字を表現するにはヘッダファイルを定義する。
",printfで文字を表現したいが、何も表示されない,ヘッダーファイルが定義されていないのでは？,,,,,,,,,,1,
2,"printfで数字を表現するにはprintf(""%d"")の形で記述します。",printfで数字を表現したいが、何も表示されない,"printf(""%d"")の形で記述できてる？",,,,,,,,,,2,
3,"数字が少数で表示するにはprintf(""%f"")を記述します。",数字が少数で表示されない,"printf(""%f"")を記述してみてください",,,,,,,,,,3,
4,scanfを実行するには変数名に＆をつける。,scanfが実行できない,変数名に＆がついていないのでは？,,,,,,,,,,4,
5,改行されないのは、文末に\n記述してないから。,改行されない,文末に\n記述したらいいよ,,,,,,,,,,5,
6,赤の波線が出てビルドできないときは、その前後の記述を注視してみよ,赤の波線が出てビルドできない,その前後の記述を注視してみよう,,,,,,,,,,6,
7,単純計算をするプログラムだけどデバックするとエラーが出るときは、全角スペースが入っていると思うよ。,単純計算をするプログラムだけどデバックするとエラーが出る,全角スペースが入っていると思うよ,,,,,,,,,,7,
8,"計算結果が出力するにはちゃんと数字を格納する。
",計算結果が出力されない,ちゃんと数字を格納できてる？,,,,,,,,,,8,
9,printfに赤い波線がでてくるときは、前の行に  ;  をつける。,printfに赤い波線がでてくる,前の行に  ;  はついていますか？,,,,,,,,,,9,
10,if文で三つの変数を比較演算するにはif(a < b && b < c)のように書いてみてください。,if文で三つの変数を比較演算したいけどできない　,if(a < b && b < c)のように書いてみてください,,,,,,,,,,10,
11,if文で2つの変数が等しい時にcを実行させたいけどできないとき、if(a==b)と記述していますか？,if文で2つの変数が等しい時にcを実行させたいけどできない,if(a==b)と記述していますか？,,,,,,,,,,11,if(a < b && b < c)のように書くと、if文で文で2つの変数が等しい時に実行できる。
12,"printfで記述したのが出力されるには""""(ダブルコーテーション)、または''（シングルコーテーション）で囲う。",printfで記述したのに文字が出力されません,"""""(ダブルコーテーション)もしくは''（シングルコーテーション）で囲っていますか？",,,,,,,,,,12,
13,#includeに赤線が出るのは、#includeとヘッダーファイルの宣言の間に空白を入れているから。,#includeに赤線が出る,#includeとヘッダーファイルの宣言の間に空白を入れていますか？,,,,,,,,,,13,
14,「'main' の以前の定義を確認してください」と表示されるのは、同じ関数名が二つあるから。,「'main' の以前の定義を確認してください」と表示されます,同じ関数名が二つありませんか？,,,,,,,,,,14,
15,条件分岐がうまく動作しないときにelseに演算を入れていませんか？else ifにしてみてください,条件分岐がうまく動作しない,elseに演算を入れていませんか？else ifにしてみてください,,,,,,,,,,15,
16,"printf内に'%d'と変数を入れているのにエラーがでるのは””と変数の間に' , ’を入れてないから。",printf内に'%d'と変数を入れているのにエラーがでる,"””と変数の間に' , ’を入れていますか？",,,,,,,,,,16,
17,for文で繰り返しがうまくいかないのは、繰り返しで使う変数の条件はあっていなから。,for文で繰り返しがうまくいかなかった,繰り返しで使う変数の条件はあっていますか,,,,,,,,,,17,
18,intで宣言した変数で計算して格納した値が正しくないのはint型で確保できる値の範囲は-2147483648〜2147483647までです。これを超える数を表示するならunsigned intを使いましょう(正の数限定)。,intで宣言した変数で計算して格納した値が正しくなかった,int型で確保できる値の範囲は-2147483648〜2147483647までです。これを超える数を表示するならunsigned intを使いましょう(正の数限定),,,,,,,,,,18,
19,整数で計算して実数で表示しようにもできないのは、int型の変数をfloat型もしくはdouble型の変数に格納しようとしてませんか？もし、格納するなら有効にするために計算式に|(したい変数型)変更したい変数名|と記述しましょう。,整数で計算して実数で表示しようにもできなかった,int型の変数をfloat型もしくはdouble型の変数に格納しようとしてませんか？もし、格納するなら有効にするために計算式に|(したい変数型)変更したい変数名|と記述しましょう,,,,,,,,,,19,
20,条件式で一致していない場合が出力されないのは、＝一つのみにしてませんか？一致しているかどうかは＝＝二つで成り立ちます。,条件式で一致していない場合が出力されない,＝一つのみにしてませんか？一致しているかどうかは＝＝二つで成り立ちます。,,,,,,,,,,20,
21,繰り返しの処理の回数が一致しないのは、インクリメント(++)、デクリメント(--)の場所を変数の前、変数の後ろと間違えているから。,繰り返しの処理の回数が一致しない,インクリメント(++)、デクリメント(--)の場所を変数の前、変数の後ろと間違えておいたりしてませんか？,,,,,,,,,,21,
22,別の関数を用意したが、処理が行われなかったのは、あらかじめ関数を宣言していますか？初めに関数名を宣言しないと処理が確実に行われません（関数プロトタイプ宣言）。,別の関数を用意したが、処理が行われなかった,あらかじめ関数を宣言していますか？初めに関数名を宣言しないと処理が確実に行われません（関数プロトタイプ宣言）,,,,,,,,,,22,
23,別の関数で計算した値が表示されなかったのは、引数（関数で利用する変数）、戻り値（別の関数から持ってくる変数）が定義できていから。ここができていないとちゃんとした処理が行われません。,別の関数で計算した値が表示されなかった,引数（関数で利用する変数）、戻り値（別の関数から持ってくる変数）が定義できていますか？ここができていないとちゃんとした処理が行われません。,,,,,,,,,,23,
24,配列に数字が入りきらなかったとき配列の要素数（[]の中身）は足りていますか？[i]と宣言すると要素数は0~i-1まで確保されます。[i]には終端記号が格納されます。,配列に数字が入りきらなかった。,配列の要素数（[]の中身）は足りていますか？[i]と宣言すると要素数は0~i-1まで確保されます。[i]には終端記号が格納されます。,,,,,,,,,,24,
25,"小数点以下が出力されないとき、出力に使う文字を""%d""もしくは変数名をint等で宣言していませんか？小数点以下を表示する文字列は""%f""もしくは""%lf""、変数名はfloatもしくはdoubleで宣言する必要があります",小数点以下が出力されません,"出力に使う文字を""%d""もしくは変数名をint等で宣言していませんか？小数点以下を表示する文字列は""%f""もしくは""%lf""、変数名はfloatもしくはdoubleで宣言する必要があります",,,,,,,,,,25,
26,配列に文字列が入りきらなかったのは、配列の要素数を書いていないから。書いていないと代入を行うことはできません,配列に文字列が代入できない。,配列の要素数を書いていますか？書いていないと代入を行うことはできません,,,,,,,,,,26,
27,未解決のシンボルというエラーが出るとき、ツールバーのファイルからファイル名のプロパティを選びC/C++という項目を選びSDLチェックをいいえと選択してみてください。,未解決のシンボルというエラーが出る,ツールバーのファイルからファイル名のプロパティを選びC/C++という項目を選びSDLチェックをいいえと選択してみてください,,,,,,,,,,27,
28,配列の長さを得るためににstrlen関数を使ったが、ビルドエラーが起こるとき#include<string.h>があるか確認してみて,配列の長さを得るためににstrlen関数を使ったが、ビルドエラーが起こる,#include<string.h>があるか確認してみて,,,,,,,,,,28,
29,main関数で宣言した変数を別の関数で処理させたけど結果が思ったようなものじゃないときローカル変数ではなく関数より上で変数を宣言するグローバル変数を使ってみましょう。,main関数で宣言した変数を別の関数で処理させたけど結果が思ったようなものじゃない,ローカル変数ではなく関数より上で変数を宣言するグローバル変数を使ってみましょう,,,,,,,,,,29,
30,処理で使う変数にエラーが出るとき宣言している変数と処理で使う変数合ってないかも。,処理で使う変数にエラーが出る,宣言している変数と処理で使う変数合ってる？,,,,,,,,,,30,
31,2次元配列のCharの変数にscanfで入力して別の関数に渡したいけどエラーが出るとき引き渡す関数の引数のChar型は2次元配列にしていますか？,2次元配列のCharの変数にscanfで入力して別の関数に渡したいけどエラーが出る,引き渡す関数の引数のChar型は2次元配列にしていますか？,,,,,,,,,,31,
32,変数名にundefinedというエラーが出るとき変数をせんげんしていますか？,変数名にundefinedというエラーが出る,変数をせんげんしていますか？,,,,,,,,,,32,
33,if文の後のprintfにエラーが出るとき'{}'の対応はちゃんとしていますか？,if文の後のprintfにエラーが出る,{}'の対応はちゃんとしていますか？,,,,,,,,,,33,
34,データを何で宣言すればいいかわからないときは、C言語のデータの基本形は大まかに分けて４つあり、今回は整数値を記憶する型を宣言しないといけません。文字でしたらchar型、整数ならint、実数ならfloatもしくはdoubleで宣言しましょう。,データを何で宣言すればいいかわからない,C言語のデータの基本形は大まかに分けて４つあり、今回は整数値を記憶する型を宣言しないといけません。文字でしたらchar型、整数ならint、実数ならfloatもしくはdoubleで宣言しましょう。,,,,,,,,,,34,
35,数字をデータに入れたのに計算できないときは、データの型をchar型で宣言していませんか？char型は文字列を表示する型なので、数値を入れても計算を行うことができません。整数でならint、実数ならfloatもしくはdoubleで宣言しましょう,数字をデータに入れたのに計算できない,データの型をchar型で宣言していませんか？char型は文字列を表示する型なので、数値を入れても計算を行うことができません。整数でならint、実数ならfloatもしくはdoubleで宣言しましょう,,,,,,,,,,35,
36,繰り返し処理が終わらないときは、繰り返し処理は指定した条件式が真である限り、実行され続けます。例えば、for文だと1つ目の式は初期値の設定、2つ目の式は繰り返しの前判定、3つ目の式は実行後に実行されるカウントのインクリメントが書かれます。ここを確認してみてください。,繰り返し処理が終わらない,繰り返し処理は指定した条件式が真である限り、実行され続けます。例えば、for文だと1つ目の式は初期値の設定、2つ目の式は繰り返しの前判定、3つ目の式は実行後に実行されるカウントのインクリメントが書かれます。ここを確認してみてください。,,,,,,,,,,36,
37,"forの繰り返しに複数の条件をつけたいときは、forの条件式は「;」（セミコロン）で区切られます。複数の条件を付けたい場合、「,」で区切ることで複数の初期値や条件式を記述することができます。",forの繰り返しに複数の条件をつけたい,"forの条件式は「;」（セミコロン）で区切られます。複数の条件を付けたい場合、「,」で区切ることで複数の初期値や条件式を記述することができます。",,,,,,,,,,37,
38,float型とdouble型何が違うかというと、どちらも実数値を表現するデータ型ですが、float型はビット長が32ビットで有効数字が10進数での7桁、double型はビット長がfloat型の倍の64ビット、有効数字が10進数での13桁という違いがあります。,float型とdouble型何が違うの？,どちらも実数値を表現するデータ型ですが、float型はビット長が32ビットで有効数字が10進数での7桁、double型はビット長がfloat型の倍の64ビット、有効数字が10進数での13桁という違いがあります。,,,,,,,,,,38,
39,関数の書き方の基本は　型　関数名　（仮引数の並び）　{ 関数の本体（関数の機能）}で記述されます。コンパイルの際に関数の仕様をチェックする必要があるため、呼び出し側では関数のプロトタイプ宣言を行わないといけません。,関数の書き方がわからない,関数の書き方の基本は　型　関数名　（仮引数の並び）　{ 関数の本体（関数の機能）}で記述されます。コンパイルの際に関数の仕様をチェックする必要があるため、呼び出し側では関数のプロトタイプ宣言を行わないといけません。,,,,,,,,,,39,
40,プロトタイプ宣言は、関数の名前や引数の数、データの型といった関数の情報を定義するものです。プロトタイプ宣言を行うことで、関数の引数などの記述に誤りがあった場合、コンパイルの時、コンパイラがエラーメッセージとして通知してくれます。,プロトタイプ宣言がわからない。,プロトタイプ宣言は、関数の名前や引数の数、データの型といった関数の情報を定義するものです。プロトタイプ宣言を行うことで、関数の引数などの記述に誤りがあった場合、コンパイルの時、コンパイラがエラーメッセージとして通知してくれます。,,,,,,,,,,40,
41,関数がうまく定義できないのは、関数には制約が大きく分けて4つあり、1.関数にはデータ型を宣言しないといけない 2.実引数と仮引数の型と数、順序が一致していなければならない。3.引数がなくても、カッコ()で引数をくくる必要がある。4.関数の結果として値を返すにはreturn文を用いる 5.関数の型を呼び出し側でも宣言しないといけない。分割コンパイルしたほかのソースファイル上の関数を使う場合は、呼び出し側で外部の関数であることを宣言しないといけない。　という条件があります。一度自分自身の関数定義をチェックしてみましょう。,関数がうまく定義できない,関数には制約が大きく分けて4つあり、1.関数にはデータ型を宣言しないといけない 2.実引数と仮引数の型と数、順序が一致していなければならない。3.引数がなくても、カッコ()で引数をくくる必要がある。4.関数の結果として値を返すにはreturn文を用いる 5.関数の型を呼び出し側でも宣言しないといけない。分割コンパイルしたほかのソースファイル上の関数を使う場合は、呼び出し側で外部の関数であることを宣言しないといけない。　という条件があります。一度自分自身の関数定義をチェックしてみましょう。,,,,,,,,,,41,
42,関数の呼び出し側とは、実際に作った関数を利用したいところを指します。例えば、mainの中で、関数を利用したいと考え、利用する場合はmainが呼び出し側となります。,関数での呼び出し側って何？,関数の呼び出し側とは、実際に作った関数を利用したいところを指します。例えば、mainの中で、関数を利用したいと考え、利用する場合はmainが呼び出し側となります。,,,,,,,,,,42,
43,関数はなぜ引数とかで渡すのかというと、関数の中で自分自身を関数として呼び出すことはできます。しかし、その場合2つの条件があり、 1.繰り返しの一般形を定める。2.繰り返しの終了を定める。といったものが必要になります。,関数はなぜ引数とかで渡すの？,基本的に宣言したデータ型や数値は関数内でしか使えません。そのために、値等を渡す場合、引数で渡す必要があります。また、計算などを行った結果が欲しい場合、returnで計算結果の値を呼び出し側へ送らないといけません。,,,,,,,,,,43,
44,関数の中で自分自身を関数として呼び出すことはできるのかというと、しかし、その場合2つの条件があり、 1.繰り返しの一般形を定める。2.繰り返しの終了を定める。といったものが必要になります。,関数を自分自身で呼び出すことはできるの？,関数の中で自分自身を関数として呼び出すことはできます。しかし、その場合2つの条件があり、 1.繰り返しの一般形を定める。2.繰り返しの終了を定める。といったものが必要になります。,,,,,,,,,,44,
45,配列を宣言するときは、配列は　配列名[要素番号]　と書く必要があり、例えばint data[4]と宣言すると0番目から3番目までの4つの整数型の両機が作られます。data[4]には終端文字が記載されているので、定義の際には注意が必要です。,配列の宣言の仕方は？,配列は　配列名[要素番号]　と書く必要があり、例えばint data[4]と宣言すると0番目から3番目までの4つの整数型の両機が作られます。data[4]には終端文字が記載されているので、定義の際には注意が必要です。,,,,,,,,,,45,
46,While文を使っていると実行がとまらくなったときは、無限ループと言います。処理内容を見返してください。＝＝を使っていたりしていませんか？,While文を使っていると実行がとまらくなりました「,無限ループと言います。処理内容を見返してください。＝＝を使っていたりしていませんか？,,,,,,,,,,46,
47,Switch文を使っているが複数のCaseが実行されるとき、各Caseごとにbreakを置く必要があります,Switch文を使っているが複数のCaseが実行される,各Caseごとにbreakを置く必要があります,,,,,,,,,,47,
48,ポインタが有効かを確認したいときは、pをポインタとするとif(*p!=NULL)と置くとよいです,ポインタが有効かを確認したいです,pをポインタとするとif(*p!=NULL)と置くとよいです,,,,,,,,,,48,
49,構造体の宣言がうまくいかないとき、構造体名の前に「strutc」があるか？{}の後ろにセミコロンがあるか？,構造体の宣言がうまくいかない,構造体名の前に「strutc」があるか？{}の後ろにセミコロンがあるか？,,,,,,,,,,49,
50,ポインタがうまく機能しないときポインタとなる宣言している変数の先頭に' * 'をつけていますか？,ポインタがうまく機能しない,ポインタとなる宣言している変数の先頭に' * 'をつけていますか？,,,,,,,,,,50,
51,ポインタを使った配列をやっているのですが思っていたような結果になるとき、ポインタを使って配列を行う場合、例えば変数aを使う場合*(a+1)と書きます。（）をつけないと違う意味になります。,ポインタを使った配列をやっているのですが思っていたような結果になりません,ポインタを使って配列を行う場合、例えば変数aを使う場合*(a+1)と書きます。（）をつけないと違う意味になります。,,,,,,,,,,51,
52,wdo-while分のあとのコードでエラーが出るとき、hileの条件の()の後ろに' ; 'があるか確認してください,do-while分のあとのコードでエラーが出る,whileの条件の()の後ろに' ; 'があるか確認してください,,,,,,,,,,52,
53,メモリを使いたいがmallocやcalllocにエラーがでるとき、メモリを使う場合プログラムの先頭に#include<memory.h>、#include<malloc.h>、#include<stdlib.h>が必要となります。,メモリを使いたいがmallocやcalllocにエラーがでる,メモリを使う場合プログラムの先頭に#include<memory.h>、#include<malloc.h>、#include<stdlib.h>が必要となります。,,,,,,,,,,53,
54,main関数とそれの引数を持った関数に分けたが結果が返ってこないプロトタイプとき、プロトタイプ宣言が必要になります。プロトタイプ宣言は関数名と（）と一緒にmain関数の上に宣言する必要があります,main関数とそれの引数を持った関数に分けたが結果が返ってこない,プロトタイプ宣言が必要になります。プロトタイプ宣言は関数名と（）と一緒にmain関数の上に宣言する必要があります,,,,,,,,,,54,
55,構造体の各メンバを参照したい時は、構造体名の後ろに' . 'または' -> 'を置き、メンバ名を書く。,構造体の各メンバを参照したい時は？,構造体名の後ろに' . 'または' -> 'を置き、メンバ名を書く。,,,,,,,,,,55,
56,＋＋aとa＋＋の違いは、＋aは前置形式でa++は後置形式である。式の中で前者を使うとaの値に1を増やしてその結果を使う。後者は１増やされる前のaの値が使われ、式の後にaの値が1増える。,#NAME?,#NAME?,,,,,,,,,,56,
57,ファイルが開けないときは開きたいファイルが実行ファイル直下にあるか確認してください。もしくは開きたいファイルのパスをファイル名を格納する配列に入れてみてください。,ファイルが開けなーーーーーい！,開きたいファイルが実行ファイル直下にあるか確認してください。もしくは開きたいファイルのパスをファイル名を格納する配列に入れてみてください。,,,,,,,,,,57,
58,関数を作ったが戻り値がうまくいかないときは、戻り値の型を確認し直してみてください。（関数の冒頭）,関数を作ったが戻り値がうまくいかない,戻り値の型を確認し直してみてください。（関数の冒頭）,,,,,,,,,,58,
59,strcpy関数を使うとエラーが起きるときは、#include<string.h>が定義されてるか確認し直して下さい。,strcpy関数を使うとエラーが起きる,#include<string.h>が定義されてるか確認し直して下さい。,,,,,,,,,,59,
60,ループ処理が終了しないときは、継続条件は設定していますか？継続条件が設定されていないと終了されません。また、継続条件の値を変化させる増減式は設定しています,ループ処理が終了しない,継続条件は設定していますか？継続条件が設定されていないと終了されません。また、継続条件の値を変化させる増減式は設定しています,,,,,,,,,,60,
61,緑色の文字は何かというと、コメントという状態です。コメント状態のものはプログラムに反映されないものになります,緑色の文字って何？,緑色の文字はコメントという状態です。コメント状態のものはプログラムに反映されないものになります,,,,,,,,,,61,
62,コメントとはプログラムに反映されない作り手のメモみたいなものです。「//〜」が//の後の一行（〜）がコメント化されます、「/*〜*/」は「/*」と「*/」で挟んだ範囲がコメント化されます。,コメントって何？,コメントとはプログラムに反映されない作り手のメモみたいなものです。「//〜」が//の後の一行（〜）がコメント化されます、「/*〜*/」は「/*」と「*/」で挟んだ範囲がコメント化されます。,,,,,,,,,,62,
63,変数などが格納されている位置(アドレス)を値とする変数をポインタというんだよ,ポインタって何？,変数などが格納されている位置(アドレス)を値とする変数をポイントというんだよ,,,,,,,,,,63,
64,While文の中身が一度も実行されずにプログラムが終了するとき、while（式）は継続条件の式です。While文に入る前の段階で式の値が偽になっていた場合はWhile文の中身は一度も実行されません,While文の中身が一度も実行されずにプログラムが終了します,while（式）は継続条件の式です。While文に入る前の段階で式の値が偽になっていた場合はWhile文の中身は一度も実行されません,,,,,,,,,,64,
65,ファイルの入出力するには、FILE型変数を作る必要があります。また、fopen関数を使う必要があります。,ファイル入出力が出来ません,ファイルの入出力には、FILE型変数を作る必要があります。また、fopen関数を使う必要があります。,,,,,,,,,,65,
66,ファイルの入出力でfcloseは何でいるのかというと、ファイルの入出力でfcloseは確保したメモリを解放するためです。ファイルの入出力ではメモリを確保するのですが、処理が終わった後もそのままだとそのメモリが使えなくなってしまいます。,ファイルの入出力でfcloseは何でいるんですか？,確保したメモリを解放するためです。ファイルの入出力ではメモリを確保するのですが、処理が終わった後もそのままだとそのメモリが使えなくなってしまいます。,,,,,,,,,,66,
67,継続条件とはfor文やwhile文などの繰り返し文では、繰り返しを終了するための式が設定されています。それが継続条件です。,継続条件とは何ですか？,for文やwhile文などの繰り返し文では、繰り返しを終了するための式が設定されています。それが継続条件です。,,,,,,,,,,67,
68,文法エラーもなく実行しているらしいのだが、うんともすんとも言わないのはフリーズではなく。変数を使っていて、添え字が暴走するとそうなることが多い。あるいは、for(k=10; k>0; k++) のように絶対終わらない終了条件を書いてしまう場合もある。いずれにしても、自分で発見出来なければダメ。printf 文を有効活用してください。,文法エラーもなく実行しているらしいのだが、うんともすんとも言わない、フリーズか？,配列変数を使っていて、添え字が暴走するとそうなることが多い。あるいは、for(k=10; k>0; k++) のように絶対終わらない終了条件を書いてしまう場合もある。いずれにしても、自分で発見出来なければダメ。printf 文を有効活用してください。,,,,,,,,,,68,
69,「int main() {」のあとにEnter キーを押しても字下げされないのは拡張子「.c」の付いたファイルへのサービスです。新規文書を作成したら、直ちに「.c」を付けたファイル名で保存しなさい,「int main() {」のあとにEnter キーを押しても字下げされません。なぜ？,字下げは拡張子「.c」の付いたファイルへのサービスです。新規文書を作成したら、直ちに「.c」を付けたファイル名で保存しなさい,,,,,,,,,,69,
70,プログラムをいじっているうちに字下げがぐちゃぐちゃになってしまい一々タブを付けたり取ったりは面倒なときは、「編集」→「選択範囲のフォーマット」メニューを実行しなさい。字下げはプログラムの構造を掴む上で重要な情報です。そのために、エディタのサポート機能を活用すべきです。新しい行を挿入する場合は、前の行の行末にカーソルを置いてからEnter キーを押してください。そうすればぐちゃぐちゃにはなりません。,プログラムをいじっているうちに字下げがぐちゃぐちゃになってしまいました。一々タブを付けたり取ったりは面倒です。何か良い方法はありませんか？,「編集」→「選択範囲のフォーマット」メニューを実行しなさい。字下げはプログラムの構造を掴む上で重要な情報です。そのために、エディタのサポート機能を活用すべきです。新しい行を挿入する場合は、前の行の行末にカーソルを置いてからEnter キーを押してください。そうすればぐちゃぐちゃにはなりません。,,,,,,,,,,70,
71,C 言語とJavaの書き方は、非常によく似ています。ただ、プログラムを作るときの考え方が違います。C言語は構造化プログラミングといいまして、フローチャートのとおりにコーディングしていけばプログラムを作っていけるんですね。,C 言語とJavaは似ているように感じますが、主にどこが違うのでしょうか？,言語の書き方は、非常によく似ています。ただ、プログラムを作るときの考え方が違います。C言語は構造化プログラミングといいまして、フローチャートのとおりにコーディングしていけばプログラムを作っていけるんですね。,,,,,,,,,,71,
72,データが入力できません、あるいは、入力したはずのデータが正しく入力できないときは、一番多いのは、変数の前に「&」を付け忘れることです。先ずそれを確認しなさい。あとは、scanf命令の変数の個数とフォーマット識別子の個数が違っているか、型がおかしいかのどれかでしょう。すぐに分からないとあきらめないで、意図したとおりのプログラムが書けているかどうかを一字一字確認しなさい。,データが入力できません、あるいは、入力したはずのデータが正しく入力されません。,一番多いのは、変数の前に「&」を付け忘れることです。先ずそれを確認しなさい。あとは、scanf命令の変数の個数とフォーマット識別子の個数が違っているか、型がおかしいかのどれかでしょう。すぐに分からないとあきらめないで、意図したとおりのプログラムが書けているかどうかを一字一字確認しなさい。,,,,,,,,,,72,
73,main関数で作った変数が、他の関数で使えないとき、変数にはスコープという有効範囲があり、特定の関数で宣言した変数はその関数内でしか使えません。他の関数で使う為には、関数呼び出しの時に引数としてその変数のアドレスを渡す必要があります。,main関数で作った変数が、他の関数で使えません！,変数にはスコープという有効範囲があり、特定の関数で宣言した変数はその関数内でしか使えません。他の関数で使う為には、関数呼び出しの時に引数としてその変数のアドレスを渡す必要があります。,,,,,,,,,,73,
74,"3桁未満の学籍番号を「""%3d""」で表示したら先頭のゼロが表示されないとき、どうすれば良いのかというとせっかく百の位、十の位、一の位の数字を計算するのだから、「""C%d%d%d-%d""」のように、間を開けずに表示させれば良いでしょう。裏技として、「%」と「3d」の間にゼロを書いて「""%03d""」とすると、「001」のように表示できます。","3桁未満の学籍番号を「""%3d""」で表示したら先頭のゼロが表示されません。どうすれば良いですか？","せっかく百の位、十の位、一の位の数字を計算するのだから、「""C%d%d%d-%d""」のように、間を開けずに表示させれば良いでしょう。裏技として、「%」と「3d」の間にゼロを書いて「""%03d""」とすると、「001」のように表示できます。",,,,,,,,,,74,
75,変数のアドレスとは、データを入れるために確保した箱（メモリ）のＰＣ上での位置を示すための住所です,変数のアドレスっなに？,変数のアドレスとは、データを入れるために確保した箱（メモリ）のＰＣ上での位置を示すための住所です,,,,,,,,,,75,
76,変数とは、数字や文字などのデータを入れるためにＰＣ上のメモリを確保した領域のことです。,変数ってなに？,変数とは、数字や文字などのデータを入れるためにＰＣ上のメモリを確保した領域のことです。,,,,,,,,,,76,
77,*(a+1)と*(a)+1の違いは、ポインタ配列をする際*(a+1)は配列の要素を足された数だけ後の要素を指しますが、*(a)+1はそれができません。,*(a+1)と*(a)+1の違いって何？,ポインタ配列をする際*(a+1)は配列の要素を足された数だけ後の要素を指しますが、*(a)+1はそれができません。,,,,,,,,,,77,
78,FILE型変数とはファイルの入出力に使う変数です。,FILE型変数ってなに？,ファイルの入出力に使う変数です。,,,,,,,,,,78,
79,strrev という関数がみつからないのは、strrev という関数はANSI Cには定義されていません。ある関数が標準関数かどうかは、 K&R 2nd.を見るか、あるいはコンパイラのリファレンスマニュアルを見れば 判断できるはずです。,strrev という関数がみつからない。,strrev という関数はANSI Cには定義されていません。ある関数が標準関数かどうかは、 K&R 2nd.を見るか、あるいはコンパイラのリファレンスマニュアルを見れば 判断できるはずです。,,,,,,,,,,79,
80,strcat とはどういう処理をする関数なのか。なぜこのような奇妙な名前が付いているのかというと、strcat は、既にある文字列の後に、新たな文字列を連結する処理をします。catというの はconcatenateの略と言われています。,strcat とはどういう処理をする関数なのか。なぜこのような奇妙な名前が付いているのか。,strcat は、既にある文字列の後に、新たな文字列を連結する処理をします。catというの はconcatenateの略と言われています。,,,,,,,,,,80,
81,不定とは、C言語の仕様としては正しい書き方であるが、その結果が決まっていないような ふるまいのことをいいます。,不定とは何か。,C言語の仕様としては正しい書き方であるが、その結果が決まっていないような ふるまいのことをいいます。,,,,,,,,,,81,
82,"printf(""%s"", s); のように呼び出す書き方があるが、 printf(s); ではなぜいけないのかというと、文字列の中に書式制御文字が含まれていると、予期しない結果となるかもしれ ないからです。 ""%s"" という文字列を表示させるつもりで次のコードを実行すると、多分思った通りに 表示されないし、最悪の場合はプログラムが暴走するかもしれません。","printf(""%s"", s); のように呼び出す書き方があるが、 printf(s); ではなぜいけないのか。","文字列の中に書式制御文字が含まれていると、予期しない結果となるかもしれ ないからです。 ""%s"" という文字列を表示させるつもりで次のコードを実行すると、多分思った通りに 表示されないし、最悪の場合はプログラムが暴走するかもしれません。",,,,,,,,,,82,
83,printf を使って '%' を出力するには%%' と書けば '%' が表示されます。,printf を使って '%' を出力するにはどうすればよいか。 '\%' としてもうまくいかなかった。,%%' と書けば '%' が表示されます。,,,,,,,,,,83,
84,漢字を含む文字列の文字数を調べるのは一般的かつ簡単な方法はありません。処理系によっては、漢字を含む文字列の 文字数を戻すような非標準のライブラリ関数が用意されているかもしれません。 やっかいな問題は、漢字の表現方法が一通りでないということです。JIS、シフト JIS、EUCなどの種類によって、文字の数え方を変えてやらなければなりません。,漢字を含む文字列の文字数を調べるにはどうすればよいか。,一般的かつ簡単な方法はありません。処理系によっては、漢字を含む文字列の 文字数を戻すような非標準のライブラリ関数が用意されているかもしれません。 やっかいな問題は、漢字の表現方法が一通りでないということです。JIS、シフト JIS、EUCなどの種類によって、文字の数え方を変えてやらなければなりません。,,,,,,,,,,84,
85,atoi の逆の処理をしたい。数を文字列に変換するにはどうすればよいかというと、sprintf を使えば簡単にできます。ただし、結果を格納することのできる領域はあらかじ め確保しておかねばなりません。,atoi の逆の処理をしたい。数を文字列に変換するにはどうすればよいか。 itoa という関数はなかった。,sprintf を使えば簡単にできます。ただし、結果を格納することのできる領域はあらかじ め確保しておかねばなりません。,,,,,,,,,,85,
86,NULLとは、ポインタの基本的な考え方は、どこかに実体があって、それがどこにあるかと いう情報を保存しておこう、というものです。すなわち、ポインタはどこかにあ る実体を指している矢印のようなものと考えられます。,NULL とは何か。,ポインタの基本的な考え方は、どこかに実体があって、それがどこにあるかと いう情報を保存しておこう、というものです。すなわち、ポインタはどこかにあ る実体を指している矢印のようなものと考えられます。,,,,,,,,,,86,
87,NUL と NULL の違いはなにかというと、NULというのは、値が0である文字コードを意味しており、ポインタとは何の関係もあ りません。null文字と表現することもあります。 NULL というのはどこも指していないポインタを意味します。従って、これらは全く別 の概念です。,NUL と NULL の違いは何か。,NUL というのは、値が0である文字コードを意味しており、ポインタとは何の関係もあ りません。null文字と表現することもあります。 NULL というのはどこも指していないポインタを意味します。従って、これらは全く別 の概念です。,,,,,,,,,,87,
88,NULL ポインタの代わりに0を使ったコードを見たことがある。なぜ NULL の代わりに0を使ってもよいのかというと、ポインタが現われるべき所に0という値が現われた場合、コンパイラはそれをヌ ルポインタと解釈する仕様になっています。 if (p != 0) のような表現が現われると、コンパイラは比較の左辺がポインタである場合には、 右辺もポインタであると考え、従って0をヌルポインタとして解釈することになり ます。,NULL ポインタの代わりに0を使ったコードを見たことがある。なぜ NULL の代わりに0を使ってもよいのか。,ポインタが現われるべき所に0という値が現われた場合、コンパイラはそれをヌ ルポインタと解釈する仕様になっています。 if (p != 0) のような表現が現われると、コンパイラは比較の左辺がポインタである場合には、 右辺もポインタであると考え、従って0をヌルポインタとして解釈することになり ます。,,,,,,,,,,88,
89,"ヌルストリングとは、文字が一つもない文字列のことをヌルストリングと表現することがあります。 これは """" と書いた場合に該当します。 strlen の引数にすると、0という値が戻ってくるはずです。",ヌルストリングとは何か。,"文字が一つもない文字列のことをヌルストリングと表現することがあります。 これは """" と書いた場合に該当します。 strlen の引数にすると、0という値が戻ってくるはずです。",,,,,,,,,,89,
90,"fopenとはファイルをオープンするための関数です。""r""リードモード、""w""ライトモード、""a""アベントモードの三つがあります。",fopenについて教えて〜？,"fopenとはファイルをオープンするための関数です。""r""リードモード、""w""ライトモード、""a""アベントモードの三つがあります。",,,,,,,,,,90,
91,ポインタ ptr に対して、 if (ptr) {} のような書き方を見たことがある。 if (ptr != NULL) のように書かなくてもよいのかというと、if (ptr) という書き方と、 if (ptr != NULL) という書き方は、 ptr がポインタである限り、全く同じ意味となります。従って、 if (ptr) と書けば十分だし、プログラマーが NULL との比較であることを明確に意志表示するために if (ptr != NULL) と書いても何の問題もありません。どちらでも同じです。,ポインタ ptr に対して、 if (ptr) {} のような書き方を見たことがある。 if (ptr != NULL) のように書かなくてもよいのか。,if (ptr) という書き方と、 if (ptr != NULL) という書き方は、 ptr がポインタである限り、全く同じ意味となります。従って、 if (ptr) と書けば十分だし、プログラマーが NULL との比較であることを明確に意志表示するために if (ptr != NULL) と書いても何の問題もありません。どちらでも同じです。,,,,,,,,,,91,
92,これらの演算子が、変数に対して1を加算したり減算するということに代わりは ありません。ただし、ポインタに対して1を加算するということは、値に1を加え るのではなく、一つ先の要素を指すような値にするという意味になります。従っ て、これらの演算子を作用させた結果、ポインタは次の(あるいは前の)要素を指 すようになります。,ポインタに対して ++ や -- の演算子を作用すると、何が起きるのか。,これらの演算子が、変数に対して1を加算したり減算するということに代わりは ありません。ただし、ポインタに対して1を加算するということは、値に1を加え るのではなく、一つ先の要素を指すような値にするという意味になります。従っ て、これらの演算子を作用させた結果、ポインタは次の(あるいは前の)要素を指 すようになります。,,,,,,,,,,92,
93,ポインタに対して ++ や -- の演算子を作用すると、何が起きるか分かりません。仕様では、この処理は与える値が NULL の時を除いて未定義となっています。このような呼び出しは行ってはいけません。,malloc で得たポインタの値を使って free を呼び出し、一旦開放した。もう一度同じ値を使って free を呼び出すと何が起きるか。,何が起きるか分かりません。仕様では、この処理は与える値が NULL の時を除いて未定義となっています。このような呼び出しは行ってはいけません。,,,,,,,,,,93,
94,fopenのリードモードとはファイルの中身を読み込むときに使う関数です。存在するファイルを読み込みます。ファイルが存在しない場合はエラーになります。,fopenのリードモードって何？,ファイルの中身を読み込むときに使う関数です。存在するファイルを読み込みます。ファイルが存在しない場合はエラーになります。,,,,,,,,,,94,
95,fopenのライトモードとはファイルの中身を上書きするときに使う関数です。ファイルが無ければ新設し、ファイルが有ればそのファイルの中身を空にします,fopenのライトモードって何？,ファイルの中身を上書きするときに使う関数です。ファイルが無ければ新設し、ファイルが有ればそのファイルの中身を空にします,,,,,,,,,,95,
96,free(NULL) を実行すると何も起きません。言い換えれば、このような呼び出しが出来ることは、仕様に よって保証されています。,free(NULL) を実行すると何が起きるか。,何も起きません。言い換えれば、このような呼び出しが出来ることは、仕様に よって保証されています。,,,,,,,,,,96,
97,malloc(0) を実行するとこの結果は、処理系により定義が異なります。移植性が低下するので、このよ うな書き方はしない方が望ましいと思います。つまり、呼び出す時点で0になるの であれば、予期する処理になるように、移植性のある書き方をすべきです。もし どうしても確実なポインタが欲しいのなら、0の代わりに1で呼び出せば、メモリ をほんの少し無駄にする代わりに移植性のある書き方にできます。,malloc(0) を実行すると何が起きるのか。,この結果は、処理系により定義が異なります。移植性が低下するので、このよ うな書き方はしない方が望ましいと思います。つまり、呼び出す時点で0になるの であれば、予期する処理になるように、移植性のある書き方をすべきです。もし どうしても確実なポインタが欲しいのなら、0の代わりに1で呼び出せば、メモリ をほんの少し無駄にする代わりに移植性のある書き方にできます。,,,,,,,,,,97,
98,リスト構造とは、リストとはデータ要素そのものと、次の構造を指すポインタを要素として持 つ構造体によって実現できるデータ構造を言います。,リスト構造とは何か。,リストとは、データ要素そのものと、次の構造を指すポインタを要素として持 つ構造体によって実現できるデータ構造を言います。,,,,,,,,,,98,
99,四捨五入する関数が見つからないとき、四捨五入するための特別な関数はありません。浮動小数点の変数xに対して小数 点以下を四捨五入する最も簡単な方法は、(int) (x + 0.5)を実行することです。ただし、この方法は負の数に対して期待した結果を得る ことができないかもしれません。,四捨五入する関数が見つからない。,四捨五入するための特別な関数はありません。浮動小数点の変数xに対して小数 点以下を四捨五入する最も簡単な方法は、(int) (x + 0.5)を実行することです。ただし、この方法は負の数に対して期待した結果を得る ことができないかもしれません。,,,,,,,,,,99,
100,main の型が int でないといけない根拠は、仕様で int と決められているから、という答えが理解しやすいでしょう。 main 関数が値を指定しないでリターンした場合にホスト環境に戻される終了状態は、 未定義とされています。コンパイラによっては、 int の関数と void の関数とでは、呼び出しの手順が異なるかもしれません。その場合 int の関数である main を想定して書かれたスタートアップルーチンは、 void と定義された main を呼び出すか、あるいはそこから戻ってくる時に、とんでもない結果になるかも しれません。,main の型が int でないといけない根拠は何か。,仕様で int と決められているから、という答えが理解しやすいでしょう。 main 関数が値を指定しないでリターンした場合にホスト環境に戻される終了状態は、 未定義とされています。コンパイラによっては、 int の関数と void の関数とでは、呼び出しの手順が異なるかもしれません。その場合 int の関数である main を想定して書かれたスタートアップルーチンは、 void と定義された main を呼び出すか、あるいはそこから戻ってくる時に、とんでもない結果になるかも しれません。,,,,,,,,,,100,
101,fopenのアベントモードとはファイルの中身を追加するときに使う関数です。ファイルが無ければ新設され、ファイルが有れば、ファイルの現在位置をファイルエンドに位置付ける。,fopenのアベントモードって何？,ファイルの中身を追加するときに使う関数です。ファイルが無ければ新設され、ファイルが有れば、ファイルの現在位置をファイルエンドに位置付ける。,,,,,,,,,,101,
102,空白はどのように使えばよいか。タブは使ってもよいかというとC言語においては、空白を書いていい所なら、いくつ空白を書くのもプログラマー の自由です。また、書かなくてよい場合に書かないのも自由です。例えば、カン マの前後に空白を置くかどうかは書く人の判断に任されています。これはプログ ラムの処理には何等影響を及ぼしません。,空白はどのように使えばよいか。タブは使ってもよいか。,C言語においては、空白を書いていい所なら、いくつ空白を書くのもプログラマー の自由です。また、書かなくてよい場合に書かないのも自由です。例えば、カン マの前後に空白を置くかどうかは書く人の判断に任されています。これはプログ ラムの処理には何等影響を及ぼしません。,,,,,,,,,,102,
103,インデントをどのような規則で付けたらよいのかというと基本的には、ある特別な条件においてのみ実行される箇所は、その外よりも一 段深く書く、という規則です,インデントをどのような規則で付けたらよいのかわからない。,基本的には、ある特別な条件においてのみ実行される箇所は、その外よりも一 段深く書く、という規則です,,,,,,,,,,103,
104,return (0); のようなコードを見た。なぜ括弧が必要なのかというと、括弧がある方が見やすいと主張する人もいますが、たいした根拠はありません。 括弧がない場合、うっかり retrun (0); と書いてしまった時に、全てのコンパイル が終了してリンクし終わる寸前に「 retrun という関数が定義されていない」というエラーが発生するまで気付かないかもし れません。たまたま retrun という名前の関数があったら、もっと面白いことになります。,return (0); のようなコードを見た。なぜ括弧が必要なのか。,括弧がある方が見やすいと主張する人もいますが、たいした根拠はありません。 括弧がない場合、うっかり retrun (0); と書いてしまった時に、全てのコンパイル が終了してリンクし終わる寸前に「 retrun という関数が定義されていない」というエラーが発生するまで気付かないかもし れません。たまたま retrun という名前の関数があったら、もっと面白いことになります。,,,,,,,,,,104,
105,goto は使ってはいけないのは、goto を使うと処理の流れが分かりにくくなることが多いからです。,goto は使ってはいけないのはなぜ？,goto を使うと処理の流れが分かりにくくなることが多いからです。,,,,,,,,,,105,
106,未定義とは、その結果どうなるかが、言語仕様として決められていないことを 意味します。そして、その結果がどうなっても、そのＣ言語の処理系はは規格に 合致しているとみなされます。コンパイラは未定義のコードを処理する時に独自 の解釈をしてもよいし、あるいは、不正なコードを生成して、実行した途端にシ ステムを停止させても構いません。コンパイル時にエラーにしても構いません。,未定義とは何か。不定と何が違うのか。,未定義とは、その結果どうなるかが、言語仕様として決められていないことを 意味します。そして、その結果がどうなっても、そのＣ言語の処理系はは規格に 合致しているとみなされます。コンパイラは未定義のコードを処理する時に独自 の解釈をしてもよいし、あるいは、不正なコードを生成して、実行した途端にシ ステムを停止させても構いません。コンパイル時にエラーにしても構いません。,,,,,,,,,,106,
107,前処理のことをプリプロセッシングとも呼びます。昔のC言語処理系は、まずソースコードをプ リプロセッサと呼ばれているプログラムにかけてからコンパイラを通す、という ように段階を経た処理を行うものが主流でした。このプリプロセッサが行う処理 が“前処理”に該当します。最近のコンパイラは、一度で前処理からコンパイル までを行うものが多くなりましたが、C言語の仕様の中に、前処理という段階が依 然として残っており、プログラマーは見かけ上は前処理があってその後コンパイ ル、という段階があるように意識してコーディングする必要があります。,前処理とは何か。,プリプロセッシングとも呼びます。昔のC言語処理系は、まずソースコードをプ リプロセッサと呼ばれているプログラムにかけてからコンパイラを通す、という ように段階を経た処理を行うものが主流でした。このプリプロセッサが行う処理 が“前処理”に該当します。最近のコンパイラは、一度で前処理からコンパイル までを行うものが多くなりましたが、C言語の仕様の中に、前処理という段階が依 然として残っており、プログラマーは見かけ上は前処理があってその後コンパイ ル、という段階があるように意識してコーディングする必要があります。,,,,,,,,,,107,
108,マルチステートメントのマクロの定義はどのようにして書けばよいかというと、単に複数の行に分けて書きたいというのであれば、行の最後に '\' を付ければ、前処理時に一行とみなされますから、見た目に複数行に書くという 目的は達成されます。しかし、ここで問題なのは、関数呼び出しと同じように使 えるマクロが欲しいということでしょう。,マルチステートメントのマクロの定義はどのようにして書けばよいか。,単に複数の行に分けて書きたいというのであれば、行の最後に '\' を付ければ、前処理時に一行とみなされますから、見た目に複数行に書くという 目的は達成されます。しかし、ここで問題なのは、関数呼び出しと同じように使 えるマクロが欲しいということでしょう。,,,,,,,,,,108,
109,"#include でファイルを読み込む場合に、ファイル名を """" で囲むのと <> で囲むのとでは、#include <ファイル名> の形式で指定した場合、このファイルは処理系によって定められた標準的なパス から検索されます。通常、これは/usr/includeなどのパスになっています。また、 コンパイラのオプションやカスタマイズファイルの定義によって、パスをユーザ ーが指定できる場合が殆どです。","#include でファイルを読み込む場合に、ファイル名を """" で囲むのと <> で囲むのとでは、何が違うのか。",#include <ファイル名> の形式で指定した場合、このファイルは処理系によって定められた標準的なパス から検索されます。通常、これは/usr/includeなどのパスになっています。また、 コンパイラのオプションやカスタマイズファイルの定義によって、パスをユーザ ーが指定できる場合が殆どです。,,,,,,,,,,109,
110,ヘッダーの中で、さらに別のヘッダーを #include することは、言語仕様としては、このようなネスティングは許されており、ANSIの仕様を満 たすためには、少なくとも8レベルのネスティングが可能でなければなりません。,ヘッダーの中で、さらに別のヘッダーを #include することはできるか。,言語仕様としては、このようなネスティングは許されており、ANSIの仕様を満 たすためには、少なくとも8レベルのネスティングが可能でなければなりません。,,,,,,,,,,110,
111,ASCII(American National Standard Code for Information Interchange)とい うのは、アメリカで用いられている標準規格の文字コードです。,ASCIIコードとは何か。,ASCII(American National Standard Code for Information Interchange)とい うのは、アメリカで用いられている標準規格の文字コードです。,,,,,,,,,,111,
112,改行コードとは、C言語では '\n' で表現される文字のことです。意味は「現表示位置を次の行の最初の位置に移動 する」(JISによる定義)です。,改行コードとは何か。,C言語では '\n' で表現される文字のことです。意味は「現表示位置を次の行の最初の位置に移動 する」(JISによる定義)です。,,,,,,,,,,112,
113,fopen のモードにテキストとバイナリがあるが、これらの違いは、の場合の方が考え方は単純で、書き込んだデータに含まれているあら ゆるコードがそっくりそのまま処理される、ということになります。,fopen のモードにテキストとバイナリがあるが、これらの違いは何か。,バイナリの場合の方が考え方は単純で、書き込んだデータに含まれているあら ゆるコードがそっくりそのまま処理される、ということになります。,,,,,,,,,,113,
114,あるファイルの最後をカットする処理が欲しいのだが、どの関数を使えばよい のか、不思議なことに、ファイルのサイズを縮小するための標準関数は用意されてい ません。つまり、この処理を一つの関数呼び出しで行うには、処理系依存の特別 に用意された関数を使うしかありません。,あるファイルの最後をカットする処理が欲しいのだが、どの関数を使えばよい のか分からない。,不思議なことに、ファイルのサイズを縮小するための標準関数は用意されてい ません。つまり、この処理を一つの関数呼び出しで行うには、処理系依存の特別 に用意された関数を使うしかありません。,,,,,,,,,,114,
115,ファイルの途中にある一行だけを変更したいとき、標準関数の中に、ファイルの途中の一部を書き換えて、長さまで変更するよう な機能を持ったものはありません。もし長さを変えずに済むのなら、ファイルを更新モードでオープンすれば、途 中の内容を変更することは可能です,ファイルの途中にある一行だけを変更したい。ファイル全体の長さが変わって しまうのだが、何かうまい方法はあるか。,標準関数の中に、ファイルの途中の一部を書き換えて、長さまで変更するよう な機能を持ったものはありません。もし長さを変えずに済むのなら、ファイルを更新モードでオープンすれば、途 中の内容を変更することは可能です,,,,,,,,,,115,
116,makeとは、C言語の一つの特徴に、プログラムをモジュール化して分割コンパイルし、最後 にリンクという処理で一つのプログラムを完成できるということがあります。モ ジュールに分割することによって、独立した処理を分離し、局所的な見通しをよ くしてバグの入り込む余地を減らす効果が見込めます。プログラムをこのようにして部分に分けると、ある一部を変更した場合に全て のファイルを再コンパイルしなくても、変更のあったファイルだけをコンパイル し直せばよいということが頻繁に起きます。この処理を手作業で行うのはばかげ ています。基本的な考え方としては、ソースファイルの変更時刻をチェックし、 前回コンパイルした時より後に更新されたファイルだけをコンパイルして、全体 をリンクし直せば、必要な作業は完了するはずです。この作業を自動的に行うプ ログラムがmakeと呼ばれているものです。,makeとは何か。,C言語の一つの特徴に、プログラムをモジュール化して分割コンパイルし、最後 にリンクという処理で一つのプログラムを完成できるということがあります。モ ジュールに分割することによって、独立した処理を分離し、局所的な見通しをよ くしてバグの入り込む余地を減らす効果が見込めます。プログラムをこのようにして部分に分けると、ある一部を変更した場合に全て のファイルを再コンパイルしなくても、変更のあったファイルだけをコンパイル し直せばよいということが頻繁に起きます。この処理を手作業で行うのはばかげ ています。基本的な考え方としては、ソースファイルの変更時刻をチェックし、 前回コンパイルした時より後に更新されたファイルだけをコンパイルして、全体 をリンクし直せば、必要な作業は完了するはずです。この作業を自動的に行うプ ログラムがmakeと呼ばれているものです。,,,,,,,,,,116,
117,大きな配列を使ったプログラムを動かそうとしたら、実行中に何の反応もなくなったようだ。配列をメモリのどこに確保しようとしたのでしょうか。自動変数の配列は、ス タックと呼ばれる、使い回しの効くエリアに確保されることがあります。この種 のメモリ獲得は、関数の呼び出し毎に行われるため、その関数が終了した時点で メモリは開放され、同じ領域を何度も別の用途に使うことができるというメリッ トがあります。ただ、この場合、スタックのサイズは意外と小さいことがあって、 しかも、あまりに大きな配列を獲得しようとしてスタックを全て使い尽くしてし まった場合に、一体何が起こるか分からないという欠点があります。スタックは 通常は十分な大きさを持っていますが、巨大な配列をスタック上に置くことはあ まり想定されていません。特に、多重の配列は、直感的にイメージするよりも大 量のメモリをあっという間に必要とすることを頭に入れておいてください。例え ば char a[100][100][100] を扱うために必要なメモリは、100×100×100バイトで、約0.95MBになります。,大きな配列を使ったプログラムを動かそうとしたら、実行中に何の反応もなく なったようだ。何が悪かったのだろうか。,配列をメモリのどこに確保しようとしたのでしょうか。自動変数の配列は、ス タックと呼ばれる、使い回しの効くエリアに確保されることがあります。この種 のメモリ獲得は、関数の呼び出し毎に行われるため、その関数が終了した時点で メモリは開放され、同じ領域を何度も別の用途に使うことができるというメリッ トがあります。ただ、この場合、スタックのサイズは意外と小さいことがあって、 しかも、あまりに大きな配列を獲得しようとしてスタックを全て使い尽くしてし まった場合に、一体何が起こるか分からないという欠点があります。スタックは 通常は十分な大きさを持っていますが、巨大な配列をスタック上に置くことはあ まり想定されていません。特に、多重の配列は、直感的にイメージするよりも大 量のメモリをあっという間に必要とすることを頭に入れておいてください。例え ば char a[100][100][100] を扱うために必要なメモリは、100×100×100バイトで、約0.95MBになります。,,,,,,,,,,117,
118,関数って何で作るのかというと、全てmain関数内に書くと可読性が悪くなるので機能ごとに関数を作って分けます。また、関数として作っておくと同じ処理を行うときに関数を呼び出すだけで使いまわすことが出来ます,関数って何で作るの？,全てmain関数内に書くと可読性が悪くなるので機能ごとに関数を作って分けます。また、関数として作っておくと同じ処理を行うときに関数を呼び出すだけで使いまわすことが出来ます,,,,,,,,,,118,
119,そもそも何でＣ言語を学ぶの？時代は○○（他の言語名）じゃないのかというと、C言語はメモリなどのハードウェアと密接な関わりがあるので、C言語を通してコンピュータの仕組み自体の理解につながります。また、IoTやOSなどのハードウェアを意識する必要がある分野では良く使われます。もう少しだけ頑張ってみましょう。,そもそも何でＣ言語を学ぶの？時代は○○（他の言語名）じゃないの？,C言語はメモリなどのハードウェアと密接な関わりがあるので、C言語を通してコンピュータの仕組み自体の理解につながります。また、IoTやOSなどのハードウェアを意識する必要がある分野では良く使われます。もう少しだけ頑張ってみましょう。,,,,,,,,,,119,
120,自宅のPCでC言語を書いて動かしてみようと思ったけど、どうすればいいのかというと、言語に限らずプログラミング言語を動かすためにはプログラミング環境が必要になります。プログラミング環境を自分のPCに設定するのは初心者には大変なので、手始めに行うのであれば「Wandbox」などのオンライン上でプログラミング環境を提供してくれるツールを使ってみるのがおススメです。,自宅のPCでC言語を書いて動かしてみようと思ったけど、どうすればいいですか？,C言語に限らずプログラミング言語を動かすためにはプログラミング環境が必要になります。プログラミング環境を自分のPCに設定するのは初心者には大変なので、手始めに行うのであれば「Wandbox」などのオンライン上でプログラミング環境を提供してくれるツールを使ってみるのがおススメです。,,,,,,,,,,120,
121,文字を表示するのに#include<stdio.h> って必要なのかというと、#include＝その位置にコピペ、stdio.h=ヘッダファイル。つまり、#include <stdio.h>はstdio.hというヘッダファイルの中身を#include<ファイル名>の位置にコピペしています。そして、#include <stdio.h>の中にはprintf関数やscanf関数などの関数定義を行っています。これがあるから、関数定義を書かずにprintf関数が使えるのです,何で文字を表示するのに#include<stdio.h> って必要なんですか？,#include＝その位置にコピペ、stdio.h=ヘッダファイル。つまり、#include <stdio.h>はstdio.hというヘッダファイルの中身を#include<ファイル名>の位置にコピペしています。そして、#include <stdio.h>の中にはprintf関数やscanf関数などの関数定義を行っています。これがあるから、関数定義を書かずにprintf関数が使えるのです,,,,,,,,,,121,
122,mallocに対するcallocのメリットは、calloc関数を使えば、構造体や共用体の内部に作られる“詰め物”のビットもすべて0になります。整数型オブジェクトの全ビットが0であれば、値も0である。しかし、値が0であるからといって全ビットが0であるという保証はありません。,mallocに対するcallocのメリットは何ですか,calloc関数を使えば、構造体や共用体の内部に作られる“詰め物”のビットもすべて0になります。整数型オブジェクトの全ビットが0であれば、値も0である。しかし、値が0であるからといって全ビットが0であるという保証はありません。,,,,,,,,,,122,
123,openという名前の関数を自作したらfopen関数が正常に動作しなくなった場合、fopen関数が、それとは別に定義さているopen関数を呼び出しています。処理系が独自に提供しているopen関数でなく、ユーザが作成したopen関数を呼び出してしまうと、矛盾が生じてしまいます。,openという名前の関数を自作したらfopen関数が正常に動作しなくなりました。,fopen関数が、それとは別に定義さているopen関数を呼び出しています。処理系が独自に提供しているopen関数でなく、ユーザが作成したopen関数を呼び出してしまうと、矛盾が生じてしまいます。,,,,,,,,,,123,
124,"実引数とは、f(a,b)のような関数を呼出し式において、a,bのような括弧で囲みコンマで区切った並びの中の式のことです",実引数ってなんですか,"例えばf(a,b)のような関数を呼出し式において、a,bのような括弧で囲みコンマで区切った並びの中の式のことです",,,,,,,,,,124,
125,"仮引数とは、例えばint f(int x, int y)のような関数宣言あるいは関数定義の一部として宣言され、関数に入る時点で値を得るオブジェクトのことです",仮引数ってなんですか,"例えばint f(int x, int y)のような関数宣言あるいは関数定義の一部として宣言され、関数に入る時点で値を得るオブジェクトのことです",,,,,,,,,,125,
126,オブジェクトとは、値を表現することができる実行環境中の記憶域の領域のことです,オブジェクトとは何ですか。,値を表現することができる実行環境中の記憶域の領域のことです,,,,,,,,,,126,
127,NULLとは、すべてのビットが0である文字です。8進型拡張表記を用いて表すと\0です。,NULLとはなんですか,すべてのビットが0である文字です。8進型拡張表記を用いて表すと\0です。,,,,,,,,,,127,
128,整数値の平均を実数で求めようとしてもうまくいかないとき、int型の整数である変数2つをdouble型である浮動小数点型の変数に代入した場合、(整数 + 整数) / 整数になるためうまくうまくできません。平均値を実数値として得たいのであれば、/による除算自体をdouble型の結果が得られるものとしなければなりません。例えば” ave = (double)(x + y) / 2; ”だと解決できます。,整数値の平均を実数で求めようとしてもうまくいかないです,int型の整数である変数2つをdouble型である浮動小数点型の変数に代入した場合、(整数 + 整数) / 整数になるためうまくうまくできません。平均値を実数値として得たいのであれば、/による除算自体をdouble型の結果が得られるものとしなければなりません。例えば” ave = (double)(x + y) / 2; ”だと解決できます。,,,,,,,,,,128,
129,"拡張表記は、逆斜線文字\に続く一つ以上の文字による、特別な文字表記です。”\n”で改行、""\t""で水平タブ位置に移動できます。",拡張表記とは何ですか。,"拡張表記は、逆斜線文字\に続く一つ以上の文字による、特別な文字表記です。”\n”で改行、""\t""で水平タブ位置に移動できます。",,,,,,,,,,129,
130,文字列とはとは、最初のNULL文字で終わり，かつそれを含む連続した文字の列を文字列（string）といいます。,文字列とは何ですか。,最初のNULL文字で終わり，かつそれを含む連続した文字の列を文字列（string）といいます。,,,,,,,,,,130,
131,Charを連結させたいがstrcatがうまく動かない場合、変数を初期化していなかったり、代入の仕方が原因だったりします。,Charを連結させたいがstrcatがうまく動きません,初期化していなかったり、代入の仕方が原因だったりします。,,,,,,,,,,131,
132,"演算した結果を整数、小数ともに表示させたいときは、printf(""整数は%d,小数は%f"",'変数','変数')で記述してみてください。",演算した結果を整数、小数ともに表示させたいです。,"printf(""整数は%d,小数は%f"",'変数','変数')で記述してみてください。",,,,,,,,,,132,
133,数字を出したいが出ないときは、変数を宣言しているか確かめてみましょう。,数字を出したいが出ない,変数を宣言しているか確かめてみましょう。,,,,,,,,,,133,
134,"printf(""%d/%d"",x,y);と書いても割り算されないときは、dのような書式指定子のみで演算はできません。printf内で演算するなばコンマ（ , ）で区切られた後の変数で行います。printf(""%d"",x/y);のように記述します。","printf(""%d/%d"",x,y);と書いても割り算されません","%dのような書式指定子のみで演算はできません。printf内で演算するなばコンマ（ , ）で区切られた後の変数で行います。printf(""%d"",x/y);のように記述します。",,,,,,,,,,134,
135,2つ目のfor文にエラーが出ときひとつ目のfor文を見直してください。' } 'が足りなかったり、’ ; 'が無かったりしていませんか？,2つ目のfor文にエラーが出ます。,ひとつ目のfor文を見直してください。' } 'が足りなかったり、’ ; 'が無かったりしていませんか？,,,,,,,,,,135,
136,構造体の変数がエラーになるときは、構造体の変数では宣言するように'int 変数名'が必要です。,構造体の変数がエラーになります,構造体の変数では宣言するように'int 変数名'が必要です。,,,,,,,,,,136,
137,"構造体を使用したいといは、無名の構造体に「point」という名前を付けます。構造体はintやdoubleと同様に、変数宣言時の型名として使用します。例えばpoint p;と宣言します。構造体の変数の後ろ」にどっと演算子(.)をつけてメンバ変数名を書くことで、それぞれのメンバ変数の値を参照したり、代入ができる。例えば構造体に変数x,yがあるとすると、p.x=2;,p.y=4;となる。",構造体を使用したい,"無名の構造体に「point」という名前を付けます。構造体はintやdoubleと同様に、変数宣言時の型名として使用します。例えばpoint p;と宣言します。構造体の変数の後ろ」にどっと演算子(.)をつけてメンバ変数名を書くことで、それぞれのメンバ変数の値を参照したり、代入ができる。例えば構造体に変数x,yがあるとすると、p.x=2;,p.y=4;となる。",,,,,,,,,,137,
138,構造体の値を初期化する時は、代入演算子＝のあとに、波括弧でくくって、宣言されている変数の初期化をコンマ区切りで書いていきます。,構造体を初期化したい,構造体の値を初期化する時は、代入演算子＝のあとに、波括弧でくくって、宣言されている変数の初期化をコンマ区切りで書いていきます。,,,,,,,,,,138,
139,構造体のコピーを渡したいときは、「ポインタ渡し」を使います。引数として渡す変数の頭に「&」(アンパサイド）をつけ、引数の型名の後ろに「*」（アスタリスク）を書くとポインタ渡しになります。,構造体のコピーを渡したい,「ポインタ渡し」を使います。引数として渡す変数の頭に「&」(アンパサイド）をつけ、引数の型名の後ろに「*」（アスタリスク）を書くとポインタ渡しになります。,,,,,,,,,,139,
140,単精度の実数とは、実数表現において4バイト／32ビットで実数を表現する方法を単精度と言います。,単精度の実数とはなんですか？,実数表現において4バイト／32ビットで実数を表現する方法を単精度と言います。,,,,,,,,,,140,
141,単精度の実数はどうやって扱うのかというと、float型を使います。倍精度のdouble型よりもサイズが小さいため、メモリを抑えたいときに使います。,単精度の実数はどうやって扱うのですか？,float型を使います。倍精度のdouble型よりもサイズが小さいため、メモリを抑えたいときに使います。,,,,,,,,,,141,
142,倍精度の実数とは、単精度の2倍のビット数（64ビット）を用いて実数を表現したものを倍精度と言います。 構文は float n; のようになります。,倍精度の実数とはなんですか？, 単精度の2倍のビット数（64ビット）を用いて実数を表現したものを倍精度と言います。 構文は　float n;　のようになります。,,,,,,,,,,142,
143,倍精度の実数はどうやって扱うのかというと、double型を使います。構文は double n; のようになります。,倍精度の実数はどうやって扱うのですか？,double型を使います。構文は　double n;　のようになります。,,,,,,,,,,143,
144,予約語とはプログラム中で自由に利用できない識別名のことを言います。例えば、int という単語が予約語だとすると、int という名前 を変数名や関数名として利用できないということです。,予約語とはなんですか？,プ ログラム中で自由に利用できない識別名のことを言います。例えば、int という単語が予約語だとすると、int という名前 を変数名や関数名として利用できないということです。,,,,,,,,,,144,
145,"予約語はどんなものがあるのかというと、auto,break,case,char,const,continue,default,do,double,else,enum,extern,float,for,goto,if,int,long,register,return,signed,sizeof,short,static,struct,switch,typedef,union,unsigned,void,volatile,while（アルファベット順）があります。",予約語はどんなものがありますか？,"auto,break,case,char,const,continue,default,do,double,else,enum,extern,float,for,goto,if,int,long,register,return,signed,sizeof,short,static,struct,switch,typedef,union,unsigned,void,volatile,while（アルファベット順）があります。",,,,,,,,,,145,
146,真偽を判定するものを扱いたいときは、bool型を扱います。変数の定義と初期化は bool b=fales;のようになります。,真偽を判定するものを扱いたいです,bool型を扱います。変数の定義と初期化は bool b=fales;のようになります。,,,,,,,,,,146,
147,ポインタとは、コンピュータプログラミングにおいて、変数や関数などが置かれたメインメモリ上の番地などを格納する特殊な変数のことです。あるオブジェクトがなんらかの論理的位置情報に基づいてアクセスできるとき、それを参照します。,ポインタとはなんですか？,コンピュータプログラミングにおいて、変数や関数などが置かれたメインメモリ上の番地などを格納する特殊な変数のことです。あるオブジェクトがなんらかの論理的位置情報に基づいてアクセスできるとき、それを参照します。,,,,,,,,,,147,
148,ポインタはどういう場面で使うのかというと、ポインタを使うことで、アドレス先の値を取得したり、変更することができます。例えば、関数の引数でポインタを使って参照渡しを行うと、複数の変数を1つの関数で処理変更できるようになります。,ポインタはどういう場面で使いますか？,ポインタを使うことで、アドレス先の値を取得したり、変更することができます。例えば、関数の引数でポインタを使って参照渡しを行うと、複数の変数を1つの関数で処理変更できるようになります。,,,,,,,,,,148,
149,ポインタはどうやって扱うのかというと、int型などのポインタを定義する場合は、型名に「*」（アスタリスク）を付けます。変数や構造体からポインタを得るときは、&演算子を使います。逆にポインタの示すメモリの値を取得する場合は、*演算子を使います。,ポインタはどうやって扱うのですか？,int型などのポインタを定義する場合は、型名に「*」（アスタリスク）を付けます。変数や構造体からポインタを得るときは、&演算子を使います。逆にポインタの示すメモリの値を取得する場合は、*演算子を使います。,,,,,,,,,,149,
150,配列とは、一つの変数の中に、複数の値を入れることが出来るものです。,配列とは何ですか？,一つの変数の中に、複数の値を入れることが出来るものです。,,,,,,,,,,150,
151,"配列の定義構文（宣言）はどんなのかよいうと、配列では、[]演算子と添え字と呼ばれる数値で、配列内のデータにアクセスすることもできます。int型の配列を定義擦る構文は int n[100]; になります。文字列で初期化する場合は char str[]=""Hello"";",配列の定義構文（宣言）はどんなのですか？,"配列では、[]演算子と添え字と呼ばれる数値で、配列内のデータにアクセスすることもできます。int型の配列を定義擦る構文は int n[100]; になります。文字列で初期化する場合は char str[]=""Hello"";",,,,,,,,,,151,
152,"配列はどうやって扱うのかというと、例えば、int test[5];のように宣言し、test[0]=80; test[1]=90...test[4]=60;と各配列に値を代入します。その後 for(int i=0;i<5;i++){print(""%d"",test[i]);}とfor文を使うと各要素んパ体を出力します。",配列はどうやって扱うのですか？,"例えば、int test[5];のように宣言し、test[0]=80; test[1]=90...test[4]=60;と各配列に値を代入します。その後 for(int i=0;i<5;i++){print(""%d"",test[i]);}とfor文を使うと各要素んパ体を出力します。",,,,,,,,,,152,
153,配列の初歩的なミスは何かというと、宣言する際の[]演算子の値は要素の数の勘違いです。例えば、 int n[5] だと5つ入っていることになりますが、配列の添え字は0から始まっているため値を代入する際 n[1]~n[5]ではなく、 n[0]~n[4] となります。,配列の初歩的なミスは何ですか？,宣言する際の[]演算子の値は要素の数の勘違いです。例えば、 int n[5] だと5つ入っていることになりますが、配列の添え字は0から始まっているため値を代入する際 n[1]~n[5]ではなく、 n[0]~n[4] となります。,,,,,,,,,,153,
154,配列と同様に連続したメモリが確保されるので、ポインタを使って連続的にアクセスできます。三次元を扱う際は int xyz[10][10][10] のように宣言します。,2次元以上の配列を教えてください。,配列と同様に連続したメモリが確保されるので、ポインタを使って連続的にアクセスできます。三次元を扱う際は int xyz[10][10][10] のように宣言します。,,,,,,,,,,154,
155,日付と時刻を扱うにはDateTimeオブジェクトを使います。,日付と時刻を扱うには,DateTimeオブジェクトを使います。,,,,,,,,,,155,
156,日付と時刻を文字列にするには、DateTimeの日付時刻の値は、ToXxxYyyString（）を使うことで、様々な形で表示することができます。例えば長い日付表現はLongDateStringとなります。,日付と時刻を文字列にするには,DateTimeの日付時刻の値は、ToXxxYyyString（）を使うことで、様々な形で表示することができます。例えば長い日付表現はLongDateStringとなります。,,,,,,,,,,156,
157,"現在の時刻を取得するには、時刻表示はtime_t型（中身はunsigned long型）の変数とstruct tm構造体を使って取得できます。
 そのままの時刻を取り出すとグリニッジ標準時となってしまう為、localtime関数を使って現地時刻に変換します。
 具体的に言うと、日本の場合グリニッジ標準時に+9時間したものが現地時間となります。これをlocaltime関数がやってくれます。
 time_t型、tm構造体、localtime関数を利用するには、time.hをインクルードします。",現在の時刻を取得するには,"時刻表示はtime_t型（中身はunsigned long型）の変数とstruct tm構造体を使って取得できます。
そのままの時刻を取り出すとグリニッジ標準時となってしまう為、localtime関数を使って現地時刻に変換します。
具体的に言うと、日本の場合グリニッジ標準時に+9時間したものが現地時間となります。これをlocaltime関数がやってくれます。
time_t型、tm構造体、localtime関数を利用するには、time.hをインクルードします。",,,,,,,,,,157,
158,staticとは、変数やメソッドが静的（スタティック）であることを示します。,staticとは何ですか？,変数やメソッドが静的（スタティック）であることを示します。,,,,,,,,,,158,
159,voidとは、関数の型として指定した時には、市の関数が戻り値を返さないことを意味します。関数の引数リストにvoidを指定すると、その関数には引数（パラメータ）が無いことを意味します。,voidとは何ですか？,関数の型として指定した時には、市の関数が戻り値を返さないことを意味します。関数の引数リストにvoidを指定すると、その関数には引数（パラメータ）が無いことを意味します。,,,,,,,,,,159,
160,"制御の流れを中断したいときは、do while,for,switchを中断するbreakがあります。またswitchの中のブロックである終了する時にも使います。",制御の流れを中断したい,"do while,for,switchを中断するbreakがあります。またswitchの中のブロックである終了する時にも使います。",,,,,,,,,,160,
161,コメントの書き方はCでは/* */を使って記述しますが，最新のCでは// という表記を使ってコメントを記述することもできます。,コメントの書き方教えて,Cでは/* */を使って記述しますが，最新のCでは// という表記を使ってコメントを記述することもできます。,,,,,,,,,,161,
162,条件によって応じて実行するコードを選択したいときは、caseを使います。switch文ステートメントの中で使い、条件に応じて実行するコードを切り替えます。,条件によって応じて実行するコードを選択したい,caseを使います。switch文ステートメントの中で使い、条件に応じて実行するコードを切り替えます。,,,,,,,,,,162,
163,printfでの文字の変換仕様は%cを使います。,printfでの文字の変換仕様は？,%cを使います。,,,,,,,,,,163,
164,ステートメントとは、一つ一つの手続きや命令、宣言などのことをステートメントあるいは「文」という。,ステートメントって何ですか？,一つ一つの手続きや命令、宣言などのことをステートメントあるいは「文」という。,,,,,,,,,,164,
165,ブロックとは、複数のステートメントを一つの文のように扱えるようまとめたものをブロックあるいは複文という。,ブロックとは何ですか？,複数のステートメントを一つの文のように扱えるようまとめたものをブロックあるいは複文という。,,,,,,,,,,165,
166,printfでの整数の変換仕様は%dを使います。,printfでの整数の変換仕様は？,%dを使います。,,,,,,,,,,166,
167,printfでの小数の変換仕様は%fを使います。,printfでの小数の変換仕様は？,%fを使います。,,,,,,,,,,167,
168,8進数の表記は数値の先頭にOをつけます。,8進数の表記は？,数値の先頭にOをつけます。,,,,,,,,,,168,
169,16進数の表記は数値の先頭にOxをつけます。,16進数の表記は？,数値の先頭にOxをつけます。,,,,,,,,,,169,
170,変数とはメモリを利用して値を記憶する仕組みのことです。,変数とは？,メモリを利用して値を記憶する仕組みのことです。,,,,,,,,,,170,
171,識別子とは変数の名前として使える文字や数字の組み合わせのことです。ただし，識別子に使える文字には規制があります。,識別子とは？,変数の名前として使える文字や数字の組み合わせのことです。ただし，識別子に使える文字には規制があります。,,,,,,,,,,171,
172,型（データ型）とは変数に記憶させる値の種類です。,型（データ型）とは？,変数に記憶させる値の種類です。,,,,,,,,,,172,
173,char型の記憶できる値の範囲は英数字1文字です。（-128~127）,char型の記憶できる値の範囲は？,英数字1文字です。（-128~127）,,,,,,,,,,173,
174,値を１増やすことをインクリメントといいます。,インクリメントって何ですか？,値を１増やすことをインクリメントといいます。,,,,,,,,,,174,
175,unsigned char型の記憶できる値の範囲は、英数字1文字（符号なし）です。（0~255）,unsigned char型の記憶できる値の範囲は？,英数字1文字（符号なし）です。（0~255）,,,,,,,,,,175,
176,short int型の記憶できる値の範囲は、整数です。（-32768~32767）,short int型の記憶できる値の範囲は？,整数です。（-32768~32767）,,,,,,,,,,176,
177,unsigned short int型の記憶できる値の範囲は、整数（符号なし）です。（0~65535）,unsigned short int型の記憶できる値の範囲は？,整数（符号なし）です。（0~65535）,,,,,,,,,,177,
178,int型の記憶できる値の範囲は、整数です。（-2147483648~2147483647）,int型の記憶できる値の範囲は？,整数です。（-2147483648~2147483647）,,,,,,,,,,178,
179,unsigned int型の記憶できる値の範囲は整数です（符号なし）。（0~4294967295）,unsigned int型の記憶できる値の範囲は？,整数です（符号なし）。（0~4294967295）,,,,,,,,,,179,
180,long int型の記憶できる値の範囲は、長整数です。（-2147483648~2147483647）,long int型の記憶できる値の範囲は？,長整数です。（-2147483648~2147483647）,,,,,,,,,,180,
181,unsigned long int型の記憶できる値の範囲は長整数です（符号なし）。（0~4294967295）,unsigned long int型の記憶できる値の範囲は？,長整数です（符号なし）。（0~4294967295）,,,,,,,,,,181,
182,float型の記憶できる値の範囲は、単精度浮動小数点です。（3.4E-38~3.4E+38）,float型の記憶できる値の範囲は？,単精度浮動小数点です。（3.4E-38~3.4E+38）,,,,,,,,,,182,
183,double型の記憶できる値の範囲は、倍精度浮動小数点です。（1.7E-308~1.7E+308）,double型の記憶できる値の範囲は？,倍精度浮動小数点です。（1.7E-308~1.7E+308）,,,,,,,,,,183,
184,long double型の記憶できる値の範囲は、拡張倍精度浮動小数点です。（1.7E-308~1.7E+308）,long double型の記憶できる値の範囲は？,拡張倍精度浮動小数点です。（1.7E-308~1.7E+308）,,,,,,,,,,184,
185,"変数の宣言方法は、""型名 識別子;""である。",変数の宣言方法は？,"""型名 識別子;""である。",,,,,,,,,,185,
186,演算子”＋”とは、加算（足し算）することです。,演算子”＋”とは？,加算（足し算）することです。,,,,,,,,,,186,
187,演算子”ー”とは、減算（引き算）することです。,演算子”ー”とは？,減算（引き算）することです。,,,,,,,,,,187,
188,演算子”＊”とは、乗算（掛け算）またはポインタ（間接参照）に使えます。,演算子”＊”とは？,乗算（掛け算）またはポインタ（間接参照）に使えます。,,,,,,,,,,188,
189,演算子”/”とは、除算（割り算）することです。,演算子”/”とは？,除算（割り算）することです。,,,,,,,,,,189,
190,演算子”%”とは剰余（除算で出したあまり）することができます。,演算子”%”とは？,剰余（除算で出したあまり）することができます。,,,,,,,,,,190,
191,演算子”~”とは補数です。,演算子”~”とは？,補数です。,,,,,,,,,,191,
192,演算子”&”とはビット論理積です。,演算子”&”とは？,ビット論理積です。,,,,,,,,,,192,
193,演算子”|”とはビット論理和です。両方０のときのみ0。それ以外は1にする演算子,演算子”|”とは？,ビット論理和です。両方０のときのみ0。それ以外は1にする演算子,,,,,,,,,,193,
194,演算子”^”とはビット排他的論理和です。両方１のときに１、それ以外は0にする演算子,演算子”^”とは？,ビット排他的論理和です。両方１のときに１、それ以外は0にする演算子,,,,,,,,,,194,
195,演算子”=”とは代入です。,演算子”=”とは？,代入です。,,,,,,,,,,195,
196,演算子”<<”とは左シフトです。まず左側にあるものを評価し、右側にあるものを次に評価します。左側の結果を整数として、右側の結果の回数分だけ左にビットシフトしたものが演算子全体の結果となります。,演算子”<<”とは？,左シフトです。まず左側にあるものを評価し、右側にあるものを次に評価します。左側の結果を整数として、右側の結果の回数分だけ左にビットシフトしたものが演算子全体の結果となります。,,,,,,,,,,196,
197,演算子>>”とは右シフトです。まず左側にあるものを評価し、右側にあるものを次に評価します。左側の結果を整数として、右側の結果の回数分だけ右に符号付きビットシフトしたものが演算子全体の結果となります。,演算子>>”とは？,右シフトです。まず左側にあるものを評価し、右側にあるものを次に評価します。左側の結果を整数として、右側の結果の回数分だけ右に符号付きビットシフトしたものが演算子全体の結果となります。,,,,,,,,,,197,
198,演算子”++”とはインクリメントです。,演算子”++”とは？,インクリメントです。,,,,,,,,,,198,
199,演算子”--”とはデクリメントです。,演算子”--”とは？,デクリメントです。,,,,,,,,,,199,
200,演算子”>”とは、大きいです。左側にあるものを先に評価し、右側にあるものを次に評価します。右側を評価した結果が左側を評価した結果よりも小さければ真になり、そうでなければ偽になります。,演算子”>”とは？,より大きいです。左側にあるものを先に評価し、右側にあるものを次に評価します。右側を評価した結果が左側を評価した結果よりも小さければ真になり、そうでなければ偽になります。,,,,,,,,,,200,
201,演算子”>=”とは以上です。,演算子”>=”とは？,以上です。,,,,,,,,,,201,
202,演算子”<”とは未満です。,演算子”<”とは？,未満です。,,,,,,,,,,202,
203,演算子”<=”とは以下です。,演算子”<=”とは？,以下です。,,,,,,,,,,203,
204,演算子”==”とは等価です。,演算子”==”とは？,等価です。,,,,,,,,,,204,
205,演算子”!=”とは非等価です。,演算子”!=”とは？,非等価です。,,,,,,,,,,205,
206,演算子”!”とは論理否定です。,演算子”!”とは？,論理否定です。,,,,,,,,,,206,
207,演算子”&&”とは論理積です。,演算子”&&”とは？,論理積です。,,,,,,,,,,207,
208,演算子”||”とは論理和です。,演算子”||”とは？,論理和です。,,,,,,,,,,208,
209,"演算子”,”とは順次です。順次とは提示された命令を提示された順番に実行していく動きです。","演算子”,”とは？",順次です。順次とは提示された命令を提示された順番に実行していく動きです。,,,,,,,,,,209,
210,演算子”()”とは関数の呼び出しまたはキャストです。,演算子”()”とは？,関数の呼び出しまたはキャストです。,,,,,,,,,,210,
211,演算子”[]”とは配列添字です。,演算子”[]”とは？,配列添字です。,,,,,,,,,,211,
212,"演算子”.”とはメンバ参照です。構造体型変数の中にあるメンバを参照（アクセス）するには， 変数名の後に ""."" （ピリオド）に続いてメンバ名を付ける。 たとえば，変数pと構造体にint型のageがあるとすると、p という変数内の age を参照するには， p.age となる。",演算子”.”とは？,"メンバ参照です。構造体型変数の中にあるメンバを参照（アクセス）するには， 変数名の後に ""."" （ピリオド）に続いてメンバ名を付ける。 たとえば，変数pと構造体にint型のageがあるとすると、p という変数内の age を参照するには， p.age となる。",,,,,,,,,,212,
213,演算子”->”とはメンバ間接参照です。構造体を扱うときに，構造体型変数を直接扱うのではなくて，構造体型変数へのポインタを介して，間接的に扱うことがよくある。 そのようなときのために，構造体型を指すポインタ値からそれが指す構造体のメンバを参照するための演算子です。,演算子”->”とは？,メンバ間接参照です。構造体を扱うときに，構造体型変数を直接扱うのではなくて，構造体型変数へのポインタを介して，間接的に扱うことがよくある。 そのようなときのために，構造体型を指すポインタ値からそれが指す構造体のメンバを参照するための演算子です。,,,,,,,,,,213,
214,演算子”? : ”とは条件判定によって、変数に代入する値を変えるときには、if文の代わりにこの条件演算子?:を使います。,演算子”? : ”とは？,条件判定によって、変数に代入する値を変えるときには、if文の代わりにこの条件演算子?:を使います。,,,,,,,,,,214,
215,リダイレクトとは標準出力がつながっている先を、ディスプレイから通常のファイルに繋ぎ替える操作をリダイレクトと言います。リダイレクトを使えば、fopen()やfprint()を使ってファイル出力に対応していないプログラムでも、実行結果を簡単にファイルに保存することができます。リダイレクトが使える環境では、パイプという機構を利用することもできます。,リダイレクトとはなんですか？,標準出力がつながっている先を、ディスプレイから通常のファイルに繋ぎ替える操作をリダイレクトと言います。リダイレクトを使えば、fopen()やfprint()を使ってファイル出力に対応していないプログラムでも、実行結果を簡単にファイルに保存することができます。リダイレクトが使える環境では、パイプという機構を利用することもできます。,,,,,,,,,,215,
216,パイプは、あるプロセス（実行中のプログラム）の標準出力を、別のプロセスの標準入力につなぎ直すことができる機能です。,パイプとはなんですか？,パイプは、あるプロセス（実行中のプログラム）の標準出力を、別のプロセスの標準入力につなぎ直すことができる機能です。,,,,,,,,,,216,
217,パイプはどうやって使うのかというと、ターミナルやコマンドプロンプトで、実行ファイルの名前を'|'（パイプまたはバーティカルバー）でつなぎます。例えば実行ファイル1と実行ファイル2があったとすると、実行ファイル名｜実行ファイル2と書きます、こうすると2つの実行ファイルが並列して同時に実行され、実行ファイル1で標準出力に出力されたデータが、実行ファイル2の標準入力び対して順次流し込まれていきます。,パイプはどうやって使うのですか？,ターミナルやコマンドプロンプトで、実行ファイルの名前を'|'（パイプまたはバーティカルバー）でつなぎます。例えば実行ファイル1と実行ファイル2があったとすると、実行ファイル名｜実行ファイル2と書きます、こうすると2つの実行ファイルが並列して同時に実行され、実行ファイル1で標準出力に出力されたデータが、実行ファイル2の標準入力び対して順次流し込まれていきます。,,,,,,,,,,217,
218,ファイルを書き込むときfprintf()やfputsで行っているのかというと、いいえ。バッファリングという仕組みが用意されていて、ファイルの操作の背後にはそれが実行されています。,ファイルを書き込むときfprintf()やfputsで行っているのですか？,いいえ。バッファリングという仕組みが用意されていて、ファイルの操作の背後にはそれが実行されています。,,,,,,,,,,218,
219,バッファリングとは、バッファという一時保管場所に溜められ、一定量のデータがたまった時点で、まとめて一気にファイルに書き出されるのです。,バッファリングって？,バッファという一時保管場所に溜められ、一定量のデータがたまった時点で、まとめて一気にファイルに書き出されるのです。,,,,,,,,,,219,
220,無限ループをやりたいときは、for文で各場合はfor(;;){実行する処理｝またはwhile(1){実行する処理｝で書きます,無限ループをやりたい,for文で各場合はfor(;;){実行する処理｝またはwhile(1){実行する処理｝で書きます,,,,,,,,,,220,
221,プログラミングの世界での角度をラジアン単位と言います。,プログラミングの世界では角度の単位が特殊なんですか？,角度をラジアン単位と言います。,,,,,,,,,,221,
222,"関数は次のように定義します。戻り値の型（int、doubleなど) 関数名（引数1,引数2){実装コード}",関数の作り方を教えて,"関数は次のように定義します。戻り値の型（int、doubleなど)　関数名（引数1,引数2){実装コード}",,,,,,,,,,222,
223,インクリメントとは、増加、増分などの意味の英単語だが、コンピュータでは数値に1を加える操作のことを指します。,インクリメントって何ですか？,インクリメントとは、増加、増分などの意味の英単語だが、コンピュータでは数値に1を加える操作のことを指します。,,,,,,,,,,223,
224,デクリメントとは、減少、減少量などの意味の英単語だが、コンピュータでは数値から1を減らす操作のことを指します。,デクリメントって何ですか？,デクリメントとは、減少、減少量などの意味の英単語だが、コンピュータでは数値から1を減らす操作のことを指します。,,,,,,,,,,224,
225,アルファベットの大文字を入力した時、小文字に変えたいときは、ASCII文字の同じ大文字小文字は、16進数で0x20、10進数で32離れています。大文字のアルファベットに0x20足せば小文字になります。,アルファベットの大文字を入力した時、小文字に変えたい。,ASCII文字の同じ大文字小文字は、16進数で0x20、10進数で32離れています。大文字のアルファベットに0x20足せば小文字になります。,,,,,,,,,,225,
226,処理する順番はこっちで決めれるのかというと、決めれません。コンパイラは、ソースコードの上から下に向かって処理します。そのため、関数の定義は、関数を使う場所よりも上に書かなければいけません。,処理する順番はこっちで決めれますか？,決めれません。コンパイラは、ソースコードの上から下に向かって処理します。そのため、関数の定義は、関数を使う場所よりも上に書かなければいけません。,,,,,,,,,,226,
227,"プログラミングを始めたいが何から始めたらいいのかというと、環境構築から始めてください。環境構築はプログラミング学習で最大の難関です。 環境構築がうまくいかず、プログラムを書き始める前に諦めてしまうことも少なくありません。
 現在はオンライン実行環境 (Playground)が提供されており、環境構築をせずにC言語を試せるようになりました。 これらはインストールが必要なく、OSに関わらず利用できるため、PCはもちろんスマートフォンやタブレットでもC言語を学べます。 本格的なプログラムを書くには機能不足ですが、C言語の文法や意味を学ぶには十分でしょう。",プログラミングを始めたいが何から始めたらいい？,"環境構築から始めてください。環境構築はプログラミング学習で最大の難関です。 環境構築がうまくいかず、プログラムを書き始める前に諦めてしまうことも少なくありません。
現在はオンライン実行環境 (Playground)が提供されており、環境構築をせずにC言語を試せるようになりました。 これらはインストールが必要なく、OSに関わらず利用できるため、PCはもちろんスマートフォンやタブレットでもC言語を学べます。 本格的なプログラムを書くには機能不足ですが、C言語の文法や意味を学ぶには十分でしょう。",,,,,,,,,,227,
228,オンラインで実行環境を整えたいときは、paiza.IOとWandboxなどがあります。ただし、機能制限があり、scanfなど入力に関する一部の機能がpaiza.IOとWandboxの両方とも使えません。なお、これらのオンライン実行環境を使う際、境界検査インターフェースを使用したプログラムはコンパイル・リンクできないので、標準Cライブラリーの非境界検査インターフェース版の関数に置き換える必要があります,オンラインで実行環境を整えたい。,paiza.IOとWandboxなどがあります。ただし、機能制限があり、scanfなど入力に関する一部の機能がpaiza.IOとWandboxの両方とも使えません。なお、これらのオンライン実行環境を使う際、境界検査インターフェースを使用したプログラムはコンパイル・リンクできないので、標準Cライブラリーの非境界検査インターフェース版の関数に置き換える必要があります,,,,,,,,,,228,
229,"paizaの使い方は、paiza.IOはギノ株式会社が運営するオンライン実行環境で、GUIに日本語を選べるのが特徴です。
 1.「コード作成を試してみる」をクリックすると編集画面に移動します。
 2.左上のプルダウンメニューでプログラミング言語を選べます。ここでは C を選択します。
 3.テキストエリアにプログラムを入力します。
 4.「実行」ボタンをクリック、もしくはCtrlキーとEnterキーを同時に押すとプログラムが実行されます。",paizaの使い方を教えて,"paiza.IOはギノ株式会社が運営するオンライン実行環境で、GUIに日本語を選べるのが特徴です。
1.「コード作成を試してみる」をクリックすると編集画面に移動します。
2.左上のプルダウンメニューでプログラミング言語を選べます。ここでは C を選択します。
3.テキストエリアにプログラムを入力します。
4.「実行」ボタンをクリック、もしくはCtrlキーとEnterキーを同時に押すとプログラムが実行されます。",,,,,,,,,,229,
230,"Wandboxは日本人有志が運営しているオンライン実行環境で、様々なプログラミング言語と言語処理系を選べるのが特徴です。
 
 1．左上のプルダウンメニューでプログラミング言語やコンパイラを選べます。ここでは C を選択します。
 2.テキストエリアにプログラムを入力します。
 3.「Run」ボタンをクリック、もしくはCtrlキーとEnterキーを同時に押すとプログラムが実行されます。",Wandboxの使い方を教えて,"Wandboxは日本人有志が運営しているオンライン実行環境で、様々なプログラミング言語と言語処理系を選べるのが特徴です。

1．左上のプルダウンメニューでプログラミング言語やコンパイラを選べます。ここでは C を選択します。
2.テキストエリアにプログラムを入力します。
3.「Run」ボタンをクリック、もしくはCtrlキーとEnterキーを同時に押すとプログラムが実行されます。",,,,,,,,,,230,
231,ソースファイルとは、Windows付属の「メモ帳」などのテキストエディタを使って、C言語のプログラムを入力し、拡張子「.c」のファイルとして保存したものです。,ソースファイルってなに？,Windows付属の「メモ帳」などのテキストエディタを使って、C言語のプログラムを入力し、拡張子「.c」のファイルとして保存したものです。,,,,,,,,,,231,
232,ソースファイルはそのままではコンピュータでの実行に適しません。そこでよりコンピュータでの実行に適した形式に翻訳する必要があります。この翻訳を行うことをコンパイルと呼び、コンパイルを行うプログラムをコンパイラと呼びます。,コンパイラってなに？,ソースファイルはそのままではコンピュータでの実行に適しません。そこでよりコンピュータでの実行に適した形式に翻訳する必要があります。この翻訳を行うことをコンパイルと呼び、コンパイルを行うプログラムをコンパイラと呼びます。,,,,,,,,,,232,
233,コンパイラとは、オブジェクトファイルとは、コンパイラした際作られる拡張子「.obj」のファイルのことを指します。,オブジェクトファイルってなに？,コンパイラした際作られる拡張子「.obj」のファイルのことを指します。,,,,,,,,,,233,
234,リンカとは、1つのオブジェクトファイルでは実行することはできず、拡張子「.exe」の実行可能ファイルを作るためには、複数のオブジェクトファイルやライブラリを結合する必要があります。この結合を行うことをリンクと呼び、リンクを行うプログラムをリンカと呼ぶ。また、多くのコンパイラはコンパイル時にリンクも自動で一緒に行うことがあります。,リンカってなんですか？,1つのオブジェクトファイルでは実行することはできず、拡張子「.exe」の実行可能ファイルを作るためには、複数のオブジェクトファイルやライブラリを結合する必要があります。この結合を行うことをリンクと呼び、リンクを行うプログラムをリンカと呼ぶ。また、多くのコンパイラはコンパイル時にリンクも自動で一緒に行うことがあります。,,,,,,,,,,234,
235,うまくコンパイラできないときのノウハウとして、コンパイルエラーが発生した場合、エラーメッセージをメモし、ヘルプ機能などを使って調べてみてください。エラーの原因は、エラーが報告された行、あるいはそれ以前の行にあります。エラーが複数報告された場合、最初のエラーから順に解消しましょう。,うまくコンパイラできないときのノウハウを教えて,コンパイルエラーが発生した場合、エラーメッセージをメモし、ヘルプ機能などを使って調べてみてください。エラーの原因は、エラーが報告された行、あるいはそれ以前の行にあります。エラーが複数報告された場合、最初のエラーから順に解消しましょう。,,,,,,,,,,235,
236,main関数とはプログラムの開始処理において、ランタイムライブラリーの初期化処理の後、最初に呼び出されるユーザープログラムのエントリーポイントです[1]。 main() は、引数を省略することはできますが、戻値は int とされ環境に実行状況を返し、0 が成功、0 以外が失敗を表します。,main関数って何ですか？,main関数はプログラムの開始処理において、ランタイムライブラリーの初期化処理の後、最初に呼び出されるユーザープログラムのエントリーポイントです[1]。 main() は、引数を省略することはできますが、戻値は int とされ環境に実行状況を返し、0 が成功、0 以外が失敗を表します。,,,,,,,,,,236,
237,エスケープシーケンス とは、コンピュータシステムにおいて、通常の文字列では表せない特殊な文字や機能を、規定された特別な文字の並びにより表したものです。,エスケープシーケンスってなんですか？,エスケープシーケンス とは、コンピュータシステムにおいて、通常の文字列では表せない特殊な文字や機能を、規定された特別な文字の並びにより表したものです。,,,,,,,,,,237,
238,文字を複数並べて出現する文字は、トライグラフ・シーケンス＝3文字表記と呼ばれるものです。??= で#、??(で [などがあります。,文字を複数並べて出現する文字があるのですか？,トライグラフ・シーケンス＝3文字表記と呼ばれるものです。??= で#、??(で [などがあります。,,,,,,,,,,238,
239,定数( Constraints )とはプログラム実行時に一定の値しかもたない数です。 変数の値がプログラム実行中に変更される場合もあるのに対して、定数の値はプログラム実行中を通して一定です。定数には整数定数、浮動小数点定数、列挙定数、文字定数があります。,定数ってなんですか？,定数( Constraints )とはプログラム実行時に一定の値しかもたない数です。 変数の値がプログラム実行中に変更される場合もあるのに対して、定数の値はプログラム実行中を通して一定です。定数には整数定数、浮動小数点定数、列挙定数、文字定数があります。,,,,,,,,,,239,
240,"整数定数とは、整数を記述するための定数です。10進数表記のほか、2進数表記や8進数表記や16進数表記を使うことができます。
 2進数表記では接頭辞として0bあるいは0Bを付け、8進数表記では接頭辞として0を付け、16進数表記では接頭辞として0xあるいは0Xを付けます。",整数定数ってなんですか？,"整数を記述するための定数です。10進数表記のほか、2進数表記や8進数表記や16進数表記を使うことができます。
2進数表記では接頭辞として0bあるいは0Bを付け、8進数表記では接頭辞として0を付け、16進数表記では接頭辞として0xあるいは0Xを付けます。",,,,,,,,,,240,
241,浮動小数点定数とは、浮動小数点数を記述するための定数です。10進数の小数点数表記のほか、有効数字部と指数部あるいは、16進数浮動小数点で表記できます。,浮動小数点定数ってなんですか？,浮動小数点数を記述するための定数です。10進数の小数点数表記のほか、有効数字部と指数部あるいは、16進数浮動小数点で表記できます。,,,,,,,,,,241,
242,列挙定数とは、ユーザによって宣言された識別子で、 int です。,列挙定数ってなんですか？,列挙定数は、ユーザによって宣言された識別子で、 int です。,,,,,,,,,,242,
243,文字定数とは、文字を記述するための定数です。半角英数記号や制御文字などが記述できます。,文字定数ってなんですか？,文字を記述するための定数です。半角英数記号や制御文字などが記述できます。,,,,,,,,,,243,
244,文字列リテラルとは、人間語で書いたプログラムの元ネタ（ソースコード）の中に直接べた書きした文字列（文字の集まり）のことです。文字列リテラル（ String literals ）には、単純文字列リテラルとワイド文字列リテラルがあります。,文字列リテラルってなんですか？,人間語で書いたプログラムの元ネタ（ソースコード）の中に直接べた書きした文字列（文字の集まり）のことです。文字列リテラル（ String literals ）には、単純文字列リテラルとワイド文字列リテラルがあります。,,,,,,,,,,244,
245,単純文字列リテラル（character string literal）とは1バイト文字または多バイト文字の文字列を記述するための定数のことです。,単純文字列リテラルってなんですか？,単純文字列リテラル（character string literal）とは1バイト文字または多バイト文字の文字列を記述するための定数のことです。,,,,,,,,,,245,
246,ワイド文字列リテラル（wide string literal）とは文字Lという接頭語をもつことを除いて，単純文字列リテラルと同一のことです。C言語では文字列は（NULL文字で終端された）文字の配列として扱われる。,ワイド文字列リテラルってなんですか？,ワイド文字列リテラル（wide string literal）とは文字Lという接頭語をもつことを除いて，単純文字列リテラルと同一のことです。C言語では文字列は（NULL文字で終端された）文字の配列として扱われる。,,,,,,,,,,246,
247,配列全体をコピーしたいときは、for文背別の配列にコピーするか、memcpy関数を用いることで、配列全体をコピーできます。 memcpy関数は、ヘッダファイル <string.h> で宣言されています。,配列全体をコピーしたい,for文背別の配列にコピーするか、memcpy関数を用いることで、配列全体をコピーできます。 memcpy関数は、ヘッダファイル <string.h> で宣言されています。,,,,,,,,,,247,
248,配列に複数の文字列をいれたいときは、文字列は行末にバックスラッシュ文字を置くことで複数行にまたがることもできますが、この方法は非推奨です。文字列処理ルーチンの便利なライブラリがありますので、別のヘッダファイルをインクルードすることで使用できます。,配列に複数の文字列をいれたい,文字列は、行末にバックスラッシュ文字を置くことで複数行にまたがることもできますが、この方法は非推奨です。文字列処理ルーチンの便利なライブラリがありますので、別のヘッダファイルをインクルードすることで使用できます。,,,,,,,,,,248,
249,\bとは、バックスペース(Backspace)のことです。現在の行で前に移動する。先頭にある場合は不定。,\bってどういう意味？,バックスペース(Backspace)のことです。現在の行で前に移動する。先頭にある場合は不定。,,,,,,,,,,249,
250,\rとは、キャリッジリターン(carriage Return)現在の行の先頭位置に移動,\rってどういう意味？,        キャリッジリターン(carriage Return)現在の行の先頭位置に移動,,,,,,,,,,250,
251,\fとは、ページフィード(Form Feed)です。次の論理ページの最初に移動します。,\fってどういう意味？,ページフィード(Form Feed)です。次の論理ページの最初に移動します。,,,,,,,,,,251,
252,\'とは、シングルクォーテーション「’」(single quotation mark)を表示させます。,\'ってどういう意味？,シングルクォーテーション「’」(single quotation mark)を表示させます。,,,,,,,,,,252,
253,"\""とは、ダブルクォーテーション「”」(double quotation mark)「”」を表示させます。","\""ってどういう意味？",ダブルクォーテーション「”」(double quotation mark)「”」を表示させます。,,,,,,,,,,253,
254,\0とは、ヌル文字(null)です。空文字（実際は8進数表記の1ケース）を意味します。,\0ってどういう意味？, ヌル文字(null)です。空文字（実際は8進数表記の1ケース）を意味します。,,,,,,,,,,254,
255,\\とは、円記号(\)を表示させます。,\\ってどういう意味？,円記号(\)を表示させます。,,,,,,,,,,255,
256,\？とは、クエスチョンマークを表示させます。,\?とはなんですか？,クエスチョンマークを表示させます。,,,,,,,,,,256,
257,\aとは、ベル音(Alert)です。ベル音を鳴らします。印字位置は不変です。,\aとはなんですか？,ベル音(Alert)です。ベル音を鳴らします。印字位置は不変です。,,,,,,,,,,257,
258,\xhhとは、16進拡張(heXadecimal)のことです。16進でhhのコードを持つ文字になります。,\xhhとはなんですか？,16進拡張(heXadecimal)のことです。16進でhhのコードを持つ文字になります。,,,,,,,,,,258,
259,\oooとは、8進拡張(octal)です。8進でoooのコードを持つ文字,\oooとはなんですか？,8進拡張(octal)です。8進でoooのコードを持つ文字,,,,,,,,,,259,
260,ceil()とは、「その数以上の最小の整数に丸める」関数です。,ceil()はどんな関数ですか？,「その数以上の最小の整数に丸める」関数です。,,,,,,,,,,260,
261,"strtok()関数を使うことで、コンマ(,)やスラッシュ(/)などの文字を「区切り文字」として、文字列を複数の文字列に分割strtok()関数を使うことで、することができます。","strtok()関数を使うことで、何ができますか？
","コンマ(,)やスラッシュ(/)などの文字を「区切り文字」として、文字列を複数の文字列に分割strtok()関数を使うことで、することができます。
",,,,,,,,,,261,
262,どの整数型を使えばよいか、どうやって決めればよいかというと、大きな値(32767より大きな値か、-32767より小さい値)が必要なら longを使う。もしメモリの効率を気にするなら(例:大きな配列がある とか構造体がたくさんあるなど)shortを使う。どうでもいいならint を使う。オーバーフローの時の性質の明確なことが大事で負の値が不 要なら、対応する符号なしの整数を使え(ただし符号付と符号なしの 整数の混在には注意すること)。,どの整数型を使えばよいか、どうやって決めればよいか。,大きな値(32767より大きな値か、-32767より小さい値)が必要なら longを使う。もしメモリの効率を気にするなら(例:大きな配列がある とか構造体がたくさんあるなど)shortを使う。どうでもいいならint を使う。オーバーフローの時の性質の明確なことが大事で負の値が不 要なら、対応する符号なしの整数を使え(ただし符号付と符号なしの 整数の混在には注意すること)。,,,,,,,,,,262,
263,"外部変数を宣言、定義する一番よい方法は、まず一つのグローバル(厳密にいえば外部(external))変数や関数に、 たくさんの""宣言""が(たくさんの変換単位に)存在してもいいが、""定 義""はただ一つしか存在してはならない。(定義とは実際に場所を確保 する宣言で、初期値があるときは初期値を与える。) 一番よい取り決 めは、各定義を関連する.cファイルに置き、外部宣言をヘッダーファ イル("".h"")に置くことである。そしてヘッダーファイルを宣言が必要 になったら必ず#includeする。定義をふくんだ.cファイルも同じヘッ ダーファイルを#includeして、コンパイラーが定義と宣言を照らし合 わせることができるようにする。",外部変数を宣言、定義する一番よい方法は。,"まず、一つのグローバル(厳密にいえば外部(external))変数や関数に、 たくさんの""宣言""が(たくさんの変換単位に)存在してもいいが、""定 義""はただ一つしか存在してはならない。(定義とは実際に場所を確保 する宣言で、初期値があるときは初期値を与える。) 一番よい取り決 めは、各定義を関連する.cファイルに置き、外部宣言をヘッダーファ イル("".h"")に置くことである。そしてヘッダーファイルを宣言が必要 になったら必ず#includeする。定義をふくんだ.cファイルも同じヘッ ダーファイルを#includeして、コンパイラーが定義と宣言を照らし合 わせることができるようにする。
",,,,,,,,,,263,
264,"関数宣言についたexternは、こういう書き方をすることで、関数の定義がたぶん別のソースファイ ルにあるということを、ほのめかすことができる。しかし以下の2つ に違いはない。
 extern int f();
 
 int f();",関数宣言についたexternは何を意味するのか。,"こういう書き方をすることで、関数の定義がたぶん別のソースファイ ルにあるということを、ほのめかすことができる。しかし以下の2つ に違いはない。
extern int f();

int f();",,,,,,,,,,264,
265,charへのポインターを返す関数へのポインターを返す関数へのポインターN個からなる配列をどうやって宣言すればよいかというと、char *(*(*a[N])())();と記述するか宣言をtypedefを使って段階的に作り出す方法があります。,charへのポインターを返す関数へのポインターを返す関数へのポインターN個からなる配列をどうやって宣言すればよいか。,char *(*(*a[N])())();と記述するか宣言をtypedefを使って段階的に作り出す方法があります。,,,,,,,,,,265,
266,同じ型を持つ関数へのポインターを返すことのできる関数をどうやっ て宣言すればよいかというと、直接に定義することはできない。汎用の関数ポインターを返す関数を 用意して、ポインターを渡すたびに関数の型にあわせて慎重にキャス トを行う。または関数が構造体を返すようにする。その構造体は、そ の関数へのポインターだけをメンバーに持つようにする。,"同じ型を持つ関数へのポインターを返すことのできる関数をどうやっ て宣言すればよいか。今、状態マシンを作っている。この状態マシン の状態ごとに関数を用意する。そして各関数が次の状態の関数へのポ インターを返す。けれど、こういう関数を宣言する方法が見つからない。
",直接に定義することはできない。汎用の関数ポインターを返す関数を 用意して、ポインターを渡すたびに関数の型にあわせて慎重にキャス トを行う。または関数が構造体を返すようにする。その構造体は、そ の関数へのポインターだけをメンバーに持つようにする。,,,,,,,,,,266,
267,私が使っているコンパイラは関数の無効な再宣言だと文句をつけるときは、関数を呼び出すところの有効範囲内に関数の宣言がないときは(おそ らく最初の関数呼び出しが関数の定義より前にあるからだろう)その 関数はintを返す(かつ引数のデータ型の情報なし)と宣言されている と考える。そのため、後で関数がint以外を返すと宣言されると不一 致が生じる。intを返さない関数は、呼び出す前に宣言しなければな らない。,"私が使っているコンパイラは関数の無効な再宣言だと文句をつける。 一度定義して、一回呼んでるだけなのに。
","関数を呼び出すところの有効範囲内に関数の宣言がないときは(おそ らく最初の関数呼び出しが関数の定義より前にあるからだろう)その 関数はintを返す(かつ引数のデータ型の情報なし)と宣言されている と考える。そのため、後で関数がint以外を返すと宣言されると不一 致が生じる。intを返さない関数は、呼び出す前に宣言しなければな らない。
",,,,,,,,,,267,
268,"明示的には初期化されていない変数の初期値について、どこまで安心 して仮定することができるか。グローバル変数の初期値が""0""で初期 化されるのなら、ヌルポインターや浮動小数についても0であること が保証されるのかといと、「静的な」寿命を持つ変数(すなわち、関数の外で宣言した変数や記 憶域クラスをstaticと宣言した変数)は、プログラマーが「=0」と打 ち込んだかのように、0に(プログラムの立ち上がり時に一度だけ)初 期化されることが保証されている。すなわちポインターは(正しい型 の:5章参照)ヌルポインターに、浮動小数は0.0に初期化される。
 「自動の(automatic)」寿命を持つ変数(すなわち、記憶域クラスを staticと宣言していないローカル変数)の中身は、明示的に初期化し ない限り、ゴミである(ゴミが役に立つかどうかは、予測できない)。
 malloc()やrealloc()を使って動的に確保した領域も、中身はゴミで あると考えたほうがいい。だから呼び出した側のプログラムで適切に 初期化しなければならない。calloc()によって確保した領域はすべて のビットが0である。しかし、この初期化も、ポインター変数や浮動 小数点表示の変数に対しては必ずしも役にたたない。","明示的には初期化されていない変数の初期値について、どこまで安心 して仮定することができるか。グローバル変数の初期値が""0""で初期 化されるのなら、ヌルポインターや浮動小数についても0であること が保証されるのか。","「静的な」寿命を持つ変数(すなわち、関数の外で宣言した変数や記 憶域クラスをstaticと宣言した変数)は、プログラマーが「=0」と打 ち込んだかのように、0に(プログラムの立ち上がり時に一度だけ)初 期化されることが保証されている。すなわちポインターは(正しい型 の:5章参照)ヌルポインターに、浮動小数は0.0に初期化される。
「自動の(automatic)」寿命を持つ変数(すなわち、記憶域クラスを staticと宣言していないローカル変数)の中身は、明示的に初期化し ない限り、ゴミである(ゴミが役に立つかどうかは、予測できない)。
malloc()やrealloc()を使って動的に確保した領域も、中身はゴミで あると考えたほうがいい。だから呼び出した側のプログラムで適切に 初期化しなければならない。calloc()によって確保した領域はすべて のビットが0である。しかし、この初期化も、ポインター変数や浮動 小数点表示の変数に対しては必ずしも役にたたない。",,,,,,,,,,268,
269,"f()
{
char a[] = ""Hello, world!"";
}
という本からそのまま写したコードなのに、コンパイルできないときは、使っているコンパイラはANSI規格ができる前のもので 「autoの集成体型(automatic aggregates)」(例:staticでないローカ ルな配列や構造体や共用体)の初期化を許してない。回避策としては、 配列をstatic(もし、その後の呼び出しで真っ新なコピーが必要でな いなら)かグローバルにする、またはポインターで代用する(もし行列 に書き込むことがないのなら)。(文字列リテラルを指すローカルの char *変数を初期化することはいつでも可能である。","f()
{
char a[] = ""Hello, world!"";
}
という本からそのまま写したコードなのに、コンパイルできない。",使っているコンパイラはANSI規格ができる前のもので 「autoの集成体型(automatic aggregates)」(例:staticでないローカ ルな配列や構造体や共用体)の初期化を許してない。回避策としては、 配列をstatic(もし、その後の呼び出しで真っ新なコピーが必要でな いなら)かグローバルにする、またはポインターで代用する(もし行列 に書き込むことがないのなら)。(文字列リテラルを指すローカルの char *変数を初期化することはいつでも可能である。,,,,,,,,,,269,
270,"char a[] = ""string literal"";とchar *p = ""string literal"";の違いは、文字列リテラルには2種類の少し違った使いみちがある。配列の初期 化指定子(char a[]の宣言で使うような)に使うときは、その配列の各 文字の初期値を指定する。その他の場所で使うときは、文字の名無し のstaticの配列となる。このときは書き込み禁止のメモリーに保存さ れるかもしれない。だから無事に値を変更できない可能性がある。式 が必要な場所では、いつもと同じく配列はその場 でポインターに変換される。だから2番目の宣言はpを名無しの配列の 最初の要素を指すように初期化する。","char a[] = ""string literal"";とchar *p = ""string literal"";の違いは何ですか？p[i]に新しい値を代入しようとするとプログラムがクラッシュします。
",文字列リテラルには2種類の少し違った使いみちがある。配列の初期 化指定子(char a[]の宣言で使うような)に使うときは、その配列の各 文字の初期値を指定する。その他の場所で使うときは、文字の名無し のstaticの配列となる。このときは書き込み禁止のメモリーに保存さ れるかもしれない。だから無事に値を変更できない可能性がある。式 が必要な場所では、いつもと同じく配列はその場 でポインターに変換される。だから2番目の宣言はpを名無しの配列の 最初の要素を指すように初期化する。,,,,,,,,,,270,
271,struct x { ... };とx thestruct;の二つの宣言の違いは、最初の形は「構造体タグ」を宣言している。二つ目の形は「typedef」 を宣言している。主な違いは二番目の宣言のほうが少しだけ抽象デー タ型らしいことである。つまり使う側は それが構造体であることを 知っている必要がない。また変数を宣言する際にstructというキーワー ドを使う必要がない。,struct x { ... };とx thestruct;の二つの宣言の違いは。,"最初の形は「構造体タグ」を宣言している。二つ目の形は「typedef」 を宣言している。主な違いは二番目の宣言のほうが少しだけ抽象デー タ型らしいことである。つまり使う側は それが構造体であることを 知っている必要がない。また変数を宣言する際にstructというキーワー ドを使う必要がない。
",,,,,,,,,,271,
272,Cであいまいな(抽象)データ型を実装する一番よい手は、よい方法の一つは使う側が構造体へのポインターを(たぶんtypedefで 隠すことまでして)使うことである。そのポインターが公には定義し てない構造体データ型を指す。,Cであいまいな(抽象)データ型を実装する一番よい手は。,よい方法の一つは使う側が構造体へのポインターを(たぶんtypedefで 隠すことまでして)使うことである。そのポインターが公には定義し てない構造体データ型を指す。,,,,,,,,,,272,
273,構造体を、変数に代入することも、関数に引数として渡すことも、関 数の戻り値としても使うこともできると聞いた。けれどK&R初版には できないと書いてあったときは、K&R初版に書いてあるのは、構造体への演算の制限は将来のコンパイ ラでは取り除かれるだろうということである。実際K&Rの初版が発行 された時点のDennis Ritchieのコンパイラには、構造体の代入も構造 体の引数渡しも用意されていた。初期のCコンパイラの中には対応し ていないものも存在したが、現在のコンパイラはすべて対応している し、ANSI C規格の一部でもある。よって使うことをためらうことはな い。,構造体を、変数に代入することも、関数に引数として渡すことも、関 数の戻り値としても使うこともできると聞いた。けれどK&R初版には できないと書いてある。,K&R初版に書いてあるのは、構造体への演算の制限は将来のコンパイ ラでは取り除かれるだろうということである。実際K&Rの初版が発行 された時点のDennis Ritchieのコンパイラには、構造体の代入も構造 体の引数渡しも用意されていた。初期のCコンパイラの中には対応し ていないものも存在したが、現在のコンパイラはすべて対応している し、ANSI C規格の一部でもある。よって使うことをためらうことはな い。,,,,,,,,,,273,
274,"なぜ構造体を比較することはできないのかというと、構造体の比較を、低レベルの操作もできるというC言語の味わいに矛 盾することなくコンパイラにやらせる単純で、よくできた方法はない。 バイト単位の比較は、構造体の中の使われていない""穴""(このような 埋め草は、後ろのフィールドの配置が正しくなるように使われる)に どんなビットパターンが来るかもしれないことを考えると使えない。 フィールド単位の比較は、大きな構造体が対象のときに、とんでもな い量のくり返しのインラインのコードを必要とする。二つの構造体を比較したいのなら、フィールド単位に比較する関数を 自分自身で書かなければならない。",なぜ構造体を比較することはできないのか。,"構造体の比較を、低レベルの操作もできるというC言語の味わいに矛 盾することなくコンパイラにやらせる単純で、よくできた方法はない。 バイト単位の比較は、構造体の中の使われていない""穴""(このような 埋め草は、後ろのフィールドの配置が正しくなるように使われる)に どんなビットパターンが来るかもしれないことを考えると使えない。 フィールド単位の比較は、大きな構造体が対象のときに、とんでもな い量のくり返しのインラインのコードを必要とする。二つの構造体を比較したいのなら、フィールド単位に比較する関数を 自分自身で書かなければならない。
",,,,,,,,,,274,
275,"どんな仕組みで構造体を引数で渡したり、関数の戻り値に使うことが できるのかというと、構造体が関数の引数として渡されるとき、構造体全体が、必要なだけ のワードを使ってスタックに積まれる(プログラマーは、このオーバー ヘッドを嫌って構造体へのポインターをかわりによく使う)。コンパ イラの中には構造体へのポインターしか渡さないものもいる。ただし、 そういうコンパイラでも引数渡しであるという意味を残しておくため に自分用のコピーを持っているかもしれない。構造体はコンパイラが用意する領域に置かれて関数から返ってくるの が一般的である。コンパイラは、この領域のアドレスを、特別な""隠 れた""引数として、呼ばれる側の関数に渡す。古いコンパイラの中に は、構造体を返すのに特別な静的な領域を使うものもあった。これは 関数を再入(リエントラント)不能にするので、ANSI Cは禁止している。",どんな仕組みで構造体を引数で渡したり、関数の戻り値に使うことが できるのか。,"構造体が関数の引数として渡されるとき、構造体全体が、必要なだけ のワードを使ってスタックに積まれる(プログラマーは、このオーバー ヘッドを嫌って構造体へのポインターをかわりによく使う)。コンパ イラの中には構造体へのポインターしか渡さないものもいる。ただし、 そういうコンパイラでも引数渡しであるという意味を残しておくため に自分用のコピーを持っているかもしれない。構造体はコンパイラが用意する領域に置かれて関数から返ってくるの が一般的である。コンパイラは、この領域のアドレスを、特別な""隠 れた""引数として、呼ばれる側の関数に渡す。古いコンパイラの中に は、構造体を返すのに特別な静的な領域を使うものもあった。これは 関数を再入(リエントラント)不能にするので、ANSI Cは禁止している。",,,,,,,,,,275,
276,構造体を引数として取る関数に定数値をどうやって渡せばよいかというと、C言語には名前のない構造体の値を作り出す方法は存在しない。一時 的に構造体の変数を使うか、構造体を作り出すちょっとした関数を用 意しなければいけない。,構造体を引数として取る関数に定数値をどうやって渡せばよいか。,C言語には名前のない構造体の値を作り出す方法は存在しない。一時 的に構造体の変数を使うか、構造体を作り出すちょっとした関数を用 意しなければいけない。,,,,,,,,,,276,
277,"構造体をデータファイルから読む、あるいはデータファイルに書き込むのはどうすればよいかというと、fwrite()を使って構造体をデータファイルに書き込むのはそんなに難 しくない。
 
 fwrite(&somestruct, sizeof somestruct, 1, fp);
 
 これに対応するfread()を使えば読み返すことができる。(ANSI Cが決 まる前のCでは、最初の引数に(char *)のキャストが必要である。大 事なのは、fwrite()はバイトへのポインターを受け取るのであって、 構造体へのポインターを受け取るのではないということである。) し かし、こうやって書き込んだデータファイルは、たいして移植性が高 いわけではない。",構造体をデータファイルから読む、あるいはデータファイルに書き込 むのはどうすればよいか。,"fwrite()を使って構造体をデータファイルに書き込むのはそんなに難 しくない。

fwrite(&somestruct, sizeof somestruct, 1, fp);

これに対応するfread()を使えば読み返すことができる。(ANSI Cが決 まる前のCでは、最初の引数に(char *)のキャストが必要である。大 事なのは、fwrite()はバイトへのポインターを受け取るのであって、 構造体へのポインターを受け取るのではないということである。) し かし、こうやって書き込んだデータファイルは、たいして移植性が高 いわけではない。",,,,,,,,,,277,
278,"私が使っているコンパイラは構造体の内部に穴を開けるので、領域は 無駄になるし、データを保存した外部のファイルに対して""バイナリー ""で入出力することができない。この埋め草を止めたり、構造体の整 列を制御することはできないのかといと、使っているコンパイラは、この制御をおこなう拡張機能を用意しているかもしれない。ただし 標準化された方法はない。","私が使っているコンパイラは構造体の内部に穴を開けるので、領域は 無駄になるし、データを保存した外部のファイルに対して""バイナリー ""で入出力することができない。この埋め草を止めたり、構造体の整 列を制御することはできないのか。","使っているコンパイラは、この制御をおこなう拡張機能を用意しているかもしれない。ただし 標準化された方法はない。
",,,,,,,,,,278,
279,構造体にsizeof演算子を使ったら、私が思っていたよりも大きな大き さを返してきたときは、構造体は、構造体を連続的に配置したときに各構造体の先頭が整列す るように、このような詰め物を持つ場合がある(内部に詰め物をする こともある)。たとえ構造体が配列の一部でないとしても、sizeofが 一貫した値を返すように、おしりの詰め物は付いたままとなる。,構造体にsizeof演算子を使ったら、私が思っていたよりも大きな大き さを返してきた。まるで、おしりに詰め物がしてあるようだ。,構造体は、構造体を連続的に配置したときに各構造体の先頭が整列す るように、このような詰め物を持つ場合がある(内部に詰め物をする こともある)。たとえ構造体が配列の一部でないとしても、sizeofが 一貫した値を返すように、おしりの詰め物は付いたままとなる。,,,,,,,,,,279,
280,"構造体内のフィールドのバイトオフセットを知る方法は、構造体内のフィールドのバイトオフセットを知る方法はANSI Cは、offsetofマクロを用意しているので、用意されている場合 は使うこと。<stddef.h>を参照。もし手に入れることができなければ、 実装の一つは以下のようになる。
 #define offsetof(type, mem) ((size_t) \
 ((char *)&((type *)0)->mem - (char *)(type *)0))
 この実装も100%の移植性を持つわけではない。コンパイラの中には、 はねつけるものがあるかもしれないが、それはそれで文法的に正しい。",構造体内のフィールドのバイトオフセットを知る方法は。,"ANSI Cは、offsetofマクロを用意しているので、用意されている場合 は使うこと。<stddef.h>を参照。もし手に入れることができなければ、 実装の一つは以下のようになる。
#define offsetof(type, mem) ((size_t) \
((char *)&((type *)0)->mem - (char *)(type *)0))
この実装も100%の移植性を持つわけではない。コンパイラの中には、 はねつけるものがあるかもしれないが、それはそれで文法的に正しい。
",,,,,,,,,,280,
281,"どうやれば構造体のフィールドを、実行時に名前でアクセスできるかというと、まずoffsetof()マクロを使って名前とオフセットの対応表を用意する。 構造体aのフィールドbのオフセットは、
 
 offsetb = offsetof(struct a, b)
 
 で与えられる。もし以下の式でstructpが、構造体の実体へのポイン ターで、bが上で計算したオフセットを持つintのフィールドとすると、 bの値は間接的に
 
 *(int *)((char *)structp + offsetb) = value;
 
 として得られる。",どうやれば構造体のフィールドを、実行時に名前でアクセスできるか。,"まずoffsetof()マクロを使って名前とオフセットの対応表を用意する。 構造体aのフィールドbのオフセットは、

offsetb = offsetof(struct a, b)

で与えられる。もし以下の式でstructpが、構造体の実体へのポイン ターで、bが上で計算したオフセットを持つintのフィールドとすると、 bの値は間接的に

*(int *)((char *)structp + offsetb) = value;

として得られる。",,,,,,,,,,281,
282,共用体を初期化することはできるかというと、共用体の最初のメンバーを初期化に使うことをANSI C規格は許してい る。他のメンバーを初期化する標準的な方法はない(そもそもANSI規 格成立より前のたいていのコンパイラで、どのメンバーを使っても初 期化することはできなかった)。,共用体を初期化することはできるか。,"共用体の最初のメンバーを初期化に使うことをANSI C規格は許してい る。他のメンバーを初期化する標準的な方法はない(そもそもANSI規 格成立より前のたいていのコンパイラで、どのメンバーを使っても初 期化することはできなかった)。
",,,,,,,,,,282,
283,"プリプロセッサーで#defineを複数使うこととコンパイラで列挙型を 使うことの違いは、現状ではほとんど違いはない。多くの人が望んだ方向とは反対に、C 規格は、列挙型とそのほかの整数型を混合して使っても問題ないと述 べている。 (もしそのような混合が明示的なキャストなしには使えな いとしたら、よく考えて使われた列挙型により、ある種のプログラミ ングの誤りを捉えることができるのであるが。)
 
 列挙型の利点としては値が自動的に与えられることと、デバッガーを 使って列挙型の値を調べる時にデバッガーがシンボリックな値を表示 してくれるかもしれないということ、また列挙型の有効範囲がブロッ クであることが挙げられる(コンパイラは、列挙型と整数が見境なく 混合して使われたときに、致命的ではない警告を出すかもしれない。 そのように混ぜて使うことは、厳密にいえば文法違反ではないけれど、 よくない作法と考えられるからである)。欠点としてはプログラマー がデータの大きさを(さっきの致命的でない警告についても)ほとんど 制御できないことが挙げられる。",プリプロセッサーで#defineを複数使うこととコンパイラで列挙型を 使うことの違いは。,"現状ではほとんど違いはない。多くの人が望んだ方向とは反対に、C 規格は、列挙型とそのほかの整数型を混合して使っても問題ないと述 べている。 (もしそのような混合が明示的なキャストなしには使えな いとしたら、よく考えて使われた列挙型により、ある種のプログラミ ングの誤りを捉えることができるのであるが。)

列挙型の利点としては値が自動的に与えられることと、デバッガーを 使って列挙型の値を調べる時にデバッガーがシンボリックな値を表示 してくれるかもしれないということ、また列挙型の有効範囲がブロッ クであることが挙げられる(コンパイラは、列挙型と整数が見境なく 混合して使われたときに、致命的ではない警告を出すかもしれない。 そのように混ぜて使うことは、厳密にいえば文法違反ではないけれど、 よくない作法と考えられるからである)。欠点としてはプログラマー がデータの大きさを(さっきの致命的でない警告についても)ほとんど 制御できないことが挙げられる。
",,,,,,,,,,283,
284,列挙型の値をシンボルで表示する楽な方法はないのかというと、ない。列挙型の定数を文字列に対応させるちょっとした関数を書けば いい。(デバッグのことしか気にしてないのなら、よくできたデバッ ガーを使えば勝手に列挙型の定数をシンボルで表示してくれるので心 配ない。),列挙型の値をシンボルで表示する楽な方法はないのか,ない。列挙型の定数を文字列に対応させるちょっとした関数を書けば いい。(デバッグのことしか気にしてないのなら、よくできたデバッ ガーを使えば勝手に列挙型の定数をシンボルで表示してくれるので心 配ない。),,,,,,,,,,284,
285,a[i] = i++;のようなこのコードはうまく動かないかというと、i++は副作用をもたらす。つまりiの値を変更する。式の他のところで iが参照されているので、このことが未定義の振舞いを引き起こす。,"このコードはうまく動かないか。

a[i] = i++;",i++は副作用をもたらす。つまりiの値を変更する。式の他のところで iが参照されているので、このことが未定義の振舞いを引き起こす。,,,,,,,,,,285,
286,"私が使っているコンパイラではint i = 7;のコードで49を出力したときは、

後置増分演算子++も後置減分演算子--も元の値を返した後で、その演 算を行う。この""後""の意味付けがしばしば誤解を招く。前回値を産み 出したすぐ後で、かつ式のその他の部分が評価される前に、++や--が 増分や減分を行うことは保証されていない。単に式が""終了""する前のどこかで更新が実行されることが保証されているだ けである。上の例では、前回値と前回値を掛け合わせてから両方の増 分を実行することをコンパイラは選んだ。
 
 副作用があいまいな部分が複数あるコードのふるまいは、常に未定義 である。(大まかに言うと、「副作用があいまいな部分が複数ある」 とは、++, --, =, +=, -=, etc. の組み合わせのいずれかが1つの式 の中に洗われ、同じオブジェクトが2回変更されたり、変更されてか ら値を調べられることを意味している。","私が使っているコンパイラでは以下のコードで49を出力する。

int i = 7;
printf(""%d\n"", i++ * i++);

評価の順にかかわりなく、56を出力するのではないのか。","後置増分演算子++も後置減分演算子--も元の値を返した後で、その演 算を行う。この""後""の意味付けがしばしば誤解を招く。前回値を産み 出したすぐ後で、かつ式のその他の部分が評価される前に、++や--が 増分や減分を行うことは保証されていない。単に式が""終了""する前のどこかで更新が実行されることが保証されているだ けである。上の例では、前回値と前回値を掛け合わせてから両方の増 分を実行することをコンパイラは選んだ。

副作用があいまいな部分が複数あるコードのふるまいは、常に未定義 である。(大まかに言うと、「副作用があいまいな部分が複数ある」 とは、++, --, =, +=, -=, etc. の組み合わせのいずれかが1つの式 の中に洗われ、同じオブジェクトが2回変更されたり、変更されてか ら値を調べられることを意味している。",,,,,,,,,,286,
287,"以下のコードをいくつかのコンパイラでコンパイルして実験してみた。
int i = 3;
i = i++;
iの値として、3を与えるもの4を与えるもの7を与えるものがあった。 上のコードの振る舞いは未定義であるのは知っている。しかしどうし て7になるのかというと、未定義の振る舞いというのは、どんなことが起っても不思議がないことを意味している。i++も++iもi+1と は違うことに注意すること。iに1加えたかったら、i=i+1かi++か++i のどれを使ってもいい。ただし組み合わせてはいけない。","以下のコードをいくつかのコンパイラでコンパイルして実験してみた。

int i = 3;
i = i++;

iの値として、3を与えるもの4を与えるもの7を与えるものがあった。 上のコードの振る舞いは未定義であるのは知っている。しかしどうし て7になるのか",未定義の振る舞いというのは、どんなことが起っても不思議がないことを意味している。i++も++iもi+1と は違うことに注意すること。iに1加えたかったら、i=i+1かi++か++i のどれを使ってもいい。ただし組み合わせてはいけない。,,,,,,,,,,287,
288,"括弧をつけて評価の順をこっちの好きなようにすることができるか。 もしできないとして、優先順位が評価の順を決めるのではないのかというと、常に順番を指定できるわけではない。演算子の優先順位や括弧を付けることは、式の評価に部分的に順序付 けをするだけである。以下の式を考えて見よう。
 
 f() + g() * h()
 
 掛け算は足し算の前に起こるということはわかっているけれど、3つ の関数のうちどの関数が最初に呼ばれるかはわからない。式の一部の評価の順序を保証する必要があるなら、明示的に一時変数 を使い複数の文に分ける必要があるかもしれない。",括弧をつけて評価の順をこっちの好きなようにすることができるか。 もしできないとして、優先順位が評価の順を決めるのではないのか。,"常に順番を指定できるわけではない。演算子の優先順位や括弧を付けることは、式の評価に部分的に順序付 けをするだけである。以下の式を考えて見よう。

f() + g() * h()

掛け算は足し算の前に起こるということはわかっているけれど、3つ の関数のうちどの関数が最初に呼ばれるかはわからない。式の一部の評価の順序を保証する必要があるなら、明示的に一時変数 を使い複数の文に分ける必要があるかもしれない。",,,,,,,,,,288,
289,"&&や||や,(コンマ)はどうなるのかというと、これらの演算子は(三項演算子?:も同様だが)特例であって、左から右 へ順に評価することが保証されている","それでは&&や||や,(コンマ)はどうなるのか。 while((c = getchar()) != EOF && c != '\n')... のようなコードを見たことがあるが。",これらの演算子は(三項演算子?:も同様だが)特例であって、左から右 へ順に評価することが保証されている,,,,,,,,,,289,
290,"複雑な式をどうやって理解すればいいのか。「副作用完了点 (sequence point)」とはなにかというと、副作用完了点とは騒ぎがおさまってすべての副作用が完了したことが 保証されている(時)点である。(つまり式の本当の終わり、 ||,&&,?:,"",""(カンマ演算子)、関数呼び出しの直前) ANSI/ISO C規格 は以下のように述べている、
 直前の副作用完了点と次の副作用完了点までの間に、 式の評価によってオブジェクトに格納された値を 変更する回数は高々一度だけでなければならない。 更に、変更前の値は、格納される値を決定するため だけにアクセスしなければならない。
 二番目の文は理解しにくい。オブジェクトに式の中で書き込むなら、 同じ式内でのそのオブジェクトに対する如何なる且つすべてのアクセ スは書き込むべき値の計算のためでなければならないと言っている。 この規則により合法な式はアクセスが明らかに変更の前に来るものに 実質的に限定される。","複雑な式をどうやって理解すればいいのか。「副作用完了点 (sequence point)」とはなにか。
","副作用完了点とは騒ぎがおさまってすべての副作用が完了したことが 保証されている(時)点である。(つまり式の本当の終わり、 ||,&&,?:,"",""(カンマ演算子)、関数呼び出しの直前) ANSI/ISO C規格 は以下のように述べている、
直前の副作用完了点と次の副作用完了点までの間に、 式の評価によってオブジェクトに格納された値を 変更する回数は高々一度だけでなければならない。 更に、変更前の値は、格納される値を決定するため だけにアクセスしなければならない。
二番目の文は理解しにくい。オブジェクトに式の中で書き込むなら、 同じ式内でのそのオブジェクトに対する如何なる且つすべてのアクセ スは書き込むべき値の計算のためでなければならないと言っている。 この規則により合法な式はアクセスが明らかに変更の前に来るものに 実質的に限定される。",,,,,,,,,,290,
291,"以下のコードがあったとして、

a[i] = i++;

a[]のどの要素に書きこまれるかはわからないが、iは確実に一つ大きくなるのかというと、いいえ。式やプログラムが未定義になったら、すべての面で未定義となる。","以下のコードがあったとして、

a[i] = i++;

a[]のどの要素に書きこまれるかはわからないが、iは確実に一つ大きくなるね。
",いいえ。式やプログラムが未定義になったら、すべての面で未定義となる。,,,,,,,,,,291,
292,式の値を使わないとして、変数に1を加えるのにi++と++iのどちらを 使えばよいのかというと、この二つは産み出す値が違うだけで、副作用だけを必要とするときは まったく同じである。,式の値を使わないとして、変数に1を加えるのにi++と++iのどちらを 使えばよいのか。,この二つは産み出す値が違うだけで、副作用だけを必要とするときは まったく同じである。,,,,,,,,,,292,
293,"なぜint a = 1000, b = 1000;のコードは私が思った通りに動かないのか。

Cの整数の拡張規則により、掛け算がintで実行される。結果は左辺の long intの変数に拡張されて代入される前に桁溢れしたり桁落ちする かもしれない、longで演算されるよう明示的にキャストを使う。
 
 long int c = (long int)a * b;
 
 (long int)(a * b)では望む結果が得られないことに注意すること。
 
 整数変数同士割算をおこなって結果を浮動小数点型の変数に代入する ときにも同じような問題が起こる。","なぜ以下のコードは私が思った通りに動かないのか。

int a = 1000, b = 1000;
long int c = a * b;
","Cの整数の拡張規則により、掛け算がintで実行される。結果は左辺の long intの変数に拡張されて代入される前に桁溢れしたり桁落ちする かもしれない、longで演算されるよう明示的にキャストを使う。

long int c = (long int)a * b;

(long int)(a * b)では望む結果が得られないことに注意すること。

整数変数同士割算をおこなって結果を浮動小数点型の変数に代入する ときにも同じような問題が起こる。",,,,,,,,,,293,
294,"条件によって、二つの変数のどちらかに代入する複雑な式がある。((condition) ? a : b) = complicated_expression;のようなコードを使ってもよいかというと、?:演算子は、たいていの演算子と同じように、値を産み出 す。値に代入することはできない。(言い換えると?:は左辺値を産み 出さない)。 本当にやりたいなら、以下のようなやり方を試せばいい。
 
 *((condition) ? &a : &b) = complicated_expression;","条件によって、二つの変数のどちらかに代入する複雑な式がある。以 下のようなコードを使ってもよいか。

((condition) ? a : b) = complicated_expression;","?:演算子は、たいていの演算子と同じように、値を産み出 す。値に代入することはできない。(言い換えると?:は左辺値を産み 出さない)。 本当にやりたいなら、以下のようなやり方を試せばいい。

*((condition) ? &a : &b) = complicated_expression;",,,,,,,,,,294,
295,"ポインターを宣言して、そのポインター用の領域を確保しようとして いる。でもうまくいかない。char *p、*p = malloc(10);のコードのどこがおかしいのか。宣言したポインターはpであって*pではない。ポインターにどこ かを指させるにはポインターの名前を使うだけでいい。
 
 p = malloc(10);
 
 指した先のメモリーを操作するときに初めて*を間接演算子として使う。
 
 *p = 'H';","ポインターを宣言して、そのポインター用の領域を確保しようとして いる。でもうまくいかない。以下のコードのどこがおかしいのか。

char *p
*p = malloc(10);","宣言したポインターはpであって*pではない。ポインターにどこ かを指させるにはポインターの名前を使うだけでいい。

p = malloc(10);

指した先のメモリーを操作するときに初めて*を間接演算子として使う。

*p = 'H';",,,,,,,,,,295,
296,"*p++はpを増分するか。それともpが指すものを増分するのかというと、*, ++, --のような単項演算子は、右から左に結び付ける。だから *p++はpを増分する(そして増分する前にpが指していた値を返す)。p が指していた値を増分するには、(*p)++を使う(副作用が起こる順序 が問題でないなら++*pでもいいだろう)。",*p++はpを増分するか。それともpが指すものを増分するのか。,"*, ++, --のような単項演算子は、右から左に結び付ける。だから *p++はpを増分する(そして増分する前にpが指していた値を返す)。p が指していた値を増分するには、(*p)++を使う(副作用が起こる順序 が問題でないなら++*pでもいいだろう)。
",,,,,,,,,,296,
297,"charのポインターがあって、そのポインターがたまたまintを指して いた。intの次へポインターを進めたい。なぜ((int *)p)++;の式ではうまくい かないのか。

C言語でキャスト演算子は「ビットが別の型を持っているふりをして、 そういう風に扱ってやろう」ということを意味していない。キャスト は変換演算子であって、それは右辺値を生みだすと定義されている。 右辺値であるとするなら、代入することも++で足し算することもでき ないことになる(pccから派生したコンパイラやgccの拡張機能が上の ような式を受け付けることは例外である)。思っていることを式にあ らわそう。以下のようにする。
 
 p = (char *)((int *)p + 1);
 
 あるいは(pはchar *なので)単に
 
 p += sizeof(int);
 
 可能なときはいつでも、最初から適切なポインター型を選ぶべきであ る。ある型を別の型とみなそうとしてはいけない。","charのポインターがあって、そのポインターがたまたまintを指して いた。intの次へポインターを進めたい。なぜ以下の式ではうまくい かないのか。

((int *)p)++;","C言語でキャスト演算子は「ビットが別の型を持っているふりをして、 そういう風に扱ってやろう」ということを意味していない。キャスト は変換演算子であって、それは右辺値を生みだすと定義されている。 右辺値であるとするなら、代入することも++で足し算することもでき ないことになる(pccから派生したコンパイラやgccの拡張機能が上の ような式を受け付けることは例外である)。思っていることを式にあ らわそう。以下のようにする。

p = (char *)((int *)p + 1);

あるいは(pはchar *なので)単に

p += sizeof(int);

可能なときはいつでも、最初から適切なポインター型を選ぶべきであ る。ある型を別の型とみなそうとしてはいけない。
",,,,,,,,,,297,
298,参照呼び出しに使うため汎用のポインターを関数に渡すのに、 void **を使うことができるかというと、移植性まで考れば不可能である。C言語には汎用のポインターへのポ インター型は存在しない。void *が汎用のポインターとして振る舞う のは、他の型のポインターをvoid *に設定したり参照するときに、自 動的に変換が行われるからである。void *以外の何かを指している void **を使って間接参照しようとすると、この変換は実行できない (隠れた正しいポインターの型がわからない)。,参照呼び出しに使うため汎用のポインターを関数に渡すのに、 void **を使うことができるか。,"移植性まで考れば不可能である。C言語には汎用のポインターへのポ インター型は存在しない。void *が汎用のポインターとして振る舞う のは、他の型のポインターをvoid *に設定したり参照するときに、自 動的に変換が行われるからである。void *以外の何かを指している void **を使って間接参照しようとすると、この変換は実行できない (隠れた正しいポインターの型がわからない)。
",,,,,,,,,,298,
299,"extern int f(int *);の関数がある。これは整数へのポインターを引数として受け取る。どうやれば定数を 参照渡しすることができるか。f(&5);のような呼び出しは、うまくいきません。一発では無理だ。一時変数を定義して、その変数のアドレスを関数に 渡さなければならない。
 
 int five = 5
 f(&five);","以下の関数がある。

extern int f(int *);

これは整数へのポインターを引数として受け取る。どうやれば定数を 参照渡しすることができるか。以下のような呼び出しは、

f(&5);
うまくいきません。","一発では無理だ。一時変数を定義して、その変数のアドレスを関数に 渡さなければならない。

int five = 5
f(&five);
",,,,,,,,,,299,
300,"Cにも""参照渡し""が用意されてるかというと、厳密にいえば、Cはいつも値渡しである。手をわずらわして 参照渡しを真似ることはできる。ポインターを引数として取る関数を 定義し、その関数を呼ぶときに引数に&演算子を使う。あるいは関数 に配列を渡すと コンパイラーは実質的に参照渡しの振りをしてくれる。しかしCは正 式の参照渡しや、C++の参照パラメーターに本当に匹敵するものは持 ち合わせていない。(ただし、関数に似せたプリプロセッサーのマク ロは、一種の""名前呼び出し""を提供する。)","Cにも""参照渡し""が用意されてるか。","厳密にいえば、Cはいつも値渡しである。手をわずらわして 参照渡しを真似ることはできる。ポインターを引数として取る関数を 定義し、その関数を呼ぶときに引数に&演算子を使う。あるいは関数 に配列を渡すと コンパイラーは実質的に参照渡しの振りをしてくれる。しかしCは正 式の参照渡しや、C++の参照パラメーターに本当に匹敵するものは持 ち合わせていない。(ただし、関数に似せたプリプロセッサーのマク ロは、一種の""名前呼び出し""を提供する。)",,,,,,,,,,300,
301,"関数を呼ぶのに、ポインターを通す方法をみたことがある。どうなってるのかというと、もともとは関数へのポインターは*演算子を使って(かつ優先順位をはっ きりさせるためのおまけのかっこを使って)""本物の""関数へ変換しな ければならなかった。
 
 int r, func(), (*fp)() = func
 r = (*fp)();
 
 また以下のように主張することも可能である。関数は常にポインター 経由で起動され""本物の""関数の名前は常にポインターに成り下がるら何も問題は ない。こういう裏付けがpccを通して広がりANSI規格にも採用された。 すなわち、
 
 r = fp();
 
 はfpが関数の名前でも、関数へのポインターでも正しく問題なく動く (この書き方は始めからあいまいさの入る余地の無いものであった。 関数へのポインターに引数が続いていれば、そのポインターが指して いる関数を呼ぶしか仕方がないもの)。*を書くことは害がないし、今 まで通り許される(許されるどころか、古いコンパイラとの互換性が 重要であれば使うことを勧める)。",関数を呼ぶのに、ポインターを通す方法をみたことがある。どうなってるの。,"もともとは関数へのポインターは*演算子を使って(かつ優先順位をはっ きりさせるためのおまけのかっこを使って)""本物の""関数へ変換しな ければならなかった。

int r, func(), (*fp)() = func
r = (*fp)();

また以下のように主張することも可能である。関数は常にポインター 経由で起動され""本物の""関数の名前は常にポインターに成り下がるら何も問題は ない。こういう裏付けがpccを通して広がりANSI規格にも採用された。 すなわち、

r = fp();

はfpが関数の名前でも、関数へのポインターでも正しく問題なく動く (この書き方は始めからあいまいさの入る余地の無いものであった。 関数へのポインターに引数が続いていれば、そのポインターが指して いる関数を呼ぶしか仕方がないもの)。*を書くことは害がないし、今 まで通り許される(許されるどころか、古いコンパイラとの互換性が 重要であれば使うことを勧める)。",,,,,,,,,,301,
302,"どうやればプログラムの中でヌルポインターを得ることができるのかというと、C言語の定義によれば、ポインターを書くべきところに現れた定数0は、 コンパイル時にヌルポインターに変換される。すなわち初期化・代入・ 比較をするときに左辺/右辺のどちらかにポインター型の変数か式が 現れたときは、コンパイラはもう一方の側の定数0がヌルポインター を要求していることを理解し、適切なデータ型のヌルポインターの値 を産み出す。したがって以下のCプログラムの断片は正しい。
 
 char *p = 0;
 if(p != 0)",どうやればプログラムの中でヌルポインターを得ることができるのか。,"C言語の定義によれば、ポインターを書くべきところに現れた定数0は、 コンパイル時にヌルポインターに変換される。すなわち初期化・代入・ 比較をするときに左辺/右辺のどちらかにポインター型の変数か式が 現れたときは、コンパイラはもう一方の側の定数0がヌルポインター を要求していることを理解し、適切なデータ型のヌルポインターの値 を産み出す。したがって以下のCプログラムの断片は正しい。

char *p = 0;
if(p != 0)",,,,,,,,,,302,
303,"ルポインターの内部表現に0でないビットパターンを使っているマシンでは、NULLはどう定義するべきかというと、ほかのどんなマシンとも同じである。0 (または((void *)0))と定義 されている。
 
 プログラマーがプログラム中に「0」や「NULL」と書いてヌルポイン ターを要求したときに、そのマシンがどんなビットパターンをヌルポ インターを表現するのに使っていたとしても、ヌルポインターを作り 出すのはコンパイラの仕事である。だからヌルポインターの内部表現 が0でないマシンでNULLを0に#defineするのは他のマシン上とおなじ ように正当である。なぜならキャストのついていない0がポインター を必要とする場所にあらわれた場合に、コンパイラは、そのマシンに 適切なヌルポインターを作り出すことができなければならないからで ある。","ヌルポインターの内部表現に0でないビットパターンを使っているマシンでは、NULLはどう定義するべきかか。
","ほかのどんなマシンとも同じである。0 (または((void *)0))と定義 されている。

プログラマーがプログラム中に「0」や「NULL」と書いてヌルポイン ターを要求したときに、そのマシンがどんなビットパターンをヌルポ インターを表現するのに使っていたとしても、ヌルポインターを作り 出すのはコンパイラの仕事である。だからヌルポインターの内部表現 が0でないマシンでNULLを0に#defineするのは他のマシン上とおなじ ように正当である。なぜならキャストのついていない0がポインター を必要とする場所にあらわれた場合に、コンパイラは、そのマシンに 適切なヌルポインターを作り出すことができなければならないからで ある。",,,,,,,,,,303,
304,"もしNULLが#define NULL ((char *)0)のように定義されているとすると、キャストされていないNULLを引数として渡す関数呼び出しが動かなく なるのでは?動かなくなる場合もある。ここで問題はデータの型が異なるとポイン ターの内部表現が異なるマシンがあることである。上の定義は、キャ ストなしのNULLをcharへのポインターを引数としてとる関数に渡すと きはうまくいくが、その他の型のポインターを関数引数として取る場 合は問題がある。この場合は文法的に正しい、
 
 FILE *fp = NULL;
 
 のような例でさえうまくいかない場合がある。
 
 にもかかわらずANSI CはNULLの定義方法としてその他に
 
 #define NULL ((void *)0)
 
 を許している。上の定義は、ポインターの型の扱いに関して間違いの あるプログラムを動くようにするし(ポインターの内部表現がどんな データ型でも同じマシンに限られる。そういう意味で役に立つとはちょっ といいにくいが)、この定義により、NULLをポインターの意味以外で 使う間違いを見つけることができるかもしれない","もしNULLが以下のように定義されているとすると、

#define NULL ((char *)0)

キャストされていないNULLを引数として渡す関数呼び出しが動かなく なるのでは?","動かなくなる場合もある。ここで問題はデータの型が異なるとポイン ターの内部表現が異なるマシンがあることである。上の定義は、キャ ストなしのNULLをcharへのポインターを引数としてとる関数に渡すと きはうまくいくが、その他の型のポインターを関数引数として取る場 合は問題がある。この場合は文法的に正しい、

FILE *fp = NULL;

のような例でさえうまくいかない場合がある。

にもかかわらずANSI CはNULLの定義方法としてその他に

#define NULL ((void *)0)

を許している。上の定義は、ポインターの型の扱いに関して間違いの あるプログラムを動くようにするし(ポインターの内部表現がどんな データ型でも同じマシンに限られる。そういう意味で役に立つとはちょっ といいにくいが)、この定義により、NULLをポインターの意味以外で 使う間違いを見つけることができるかもしれない",,,,,,,,,,304,
305,,,,,,,,,,,,,,
306,,,,,,,,,,,,,,
307,,,,,,,,,,,,,,
308,,,,,,,,,,,,,,
309,,,,,,,,,,,,,,
310,,,,,,,,,,,,,,
311,,,,,,,,,,,,,,
312,,,,,,,,,,,,,,
313,,,,,,,,,,,,,,
314,,,,,,,,,,,,,,
315,,,,,,,,,,,,,,
316,,,,,,,,,,,,,,
317,,,,,,,,,,,,,,
318,,,,,,,,,,,,,,
319,,,,,,,,,,,,,,
320,,,,,,,,,,,,,,
321,,,,,,,,,,,,,,
322,,,,,,,,,,,,,,
323,,,,,,,,,,,,,,
324,,,,,,,,,,,,,,
325,,,,,,,,,,,,,,
326,,,,,,,,,,,,,,
327,,,,,,,,,,,,,,
328,,,,,,,,,,,,,,
329,,,,,,,,,,,,,,
330,,,,,,,,,,,,,,
331,,,,,,,,,,,,,,
332,,,,,,,,,,,,,,
333,,,,,,,,,,,,,,
334,,,,,,,,,,,,,,
335,,,,,,,,,,,,,,
336,,,,,,,,,,,,,,
337,,,,,,,,,,,,,,
338,,,,,,,,,,,,,,
339,,,,,,,,,,,,,,
340,,,,,,,,,,,,,,
341,,,,,,,,,,,,,,
342,,,,,,,,,,,,,,
343,,,,,,,,,,,,,,
344,,,,,,,,,,,,,,
345,,,,,,,,,,,,,,
346,,,,,,,,,,,,,,
347,,,,,,,,,,,,,,
348,,,,,,,,,,,,,,
349,,,,,,,,,,,,,,
350,,,,,,,,,,,,,,
351,,,,,,,,,,,,,,
352,,,,,,,,,,,,,,
353,,,,,,,,,,,,,,
354,,,,,,,,,,,,,,
355,,,,,,,,,,,,,,
356,,,,,,,,,,,,,,
357,,,,,,,,,,,,,,
358,,,,,,,,,,,,,,
359,,,,,,,,,,,,,,
360,,,,,,,,,,,,,,
361,,,,,,,,,,,,,,
362,,,,,,,,,,,,,,
363,,,,,,,,,,,,,,
364,,,,,,,,,,,,,,
365,,,,,,,,,,,,,,
366,,,,,,,,,,,,,,
367,,,,,,,,,,,,,,
368,,,,,,,,,,,,,,
369,,,,,,,,,,,,,,
370,,,,,,,,,,,,,,
371,,,,,,,,,,,,,,
372,,,,,,,,,,,,,,
373,,,,,,,,,,,,,,
374,,,,,,,,,,,,,,
375,,,,,,,,,,,,,,
376,,,,,,,,,,,,,,
377,,,,,,,,,,,,,,
378,,,,,,,,,,,,,,
379,,,,,,,,,,,,,,
380,,,,,,,,,,,,,,
381,,,,,,,,,,,,,,
382,,,,,,,,,,,,,,
383,,,,,,,,,,,,,,
384,,,,,,,,,,,,,,
385,,,,,,,,,,,,,,
386,,,,,,,,,,,,,,
387,,,,,,,,,,,,,,
388,,,,,,,,,,,,,,
389,,,,,,,,,,,,,,
390,,,,,,,,,,,,,,
391,,,,,,,,,,,,,,
392,,,,,,,,,,,,,,
393,,,,,,,,,,,,,,
394,,,,,,,,,,,,,,
395,,,,,,,,,,,,,,
396,,,,,,,,,,,,,,
397,,,,,,,,,,,,,,
398,,,,,,,,,,,,,,
399,,,,,,,,,,,,,,
400,,,,,,,,,,,,,,
401,,,,,,,,,,,,,,
402,,,,,,,,,,,,,,
403,,,,,,,,,,,,,,
404,,,,,,,,,,,,,,
405,,,,,,,,,,,,,,
406,,,,,,,,,,,,,,
407,,,,,,,,,,,,,,
408,,,,,,,,,,,,,,
409,,,,,,,,,,,,,,
410,,,,,,,,,,,,,,
411,,,,,,,,,,,,,,
412,,,,,,,,,,,,,,
413,,,,,,,,,,,,,,
414,,,,,,,,,,,,,,
415,,,,,,,,,,,,,,
416,,,,,,,,,,,,,,
417,,,,,,,,,,,,,,
418,,,,,,,,,,,,,,
419,,,,,,,,,,,,,,
420,,,,,,,,,,,,,,
421,,,,,,,,,,,,,,
422,,,,,,,,,,,,,,
423,,,,,,,,,,,,,,
424,,,,,,,,,,,,,,
425,,,,,,,,,,,,,,
426,,,,,,,,,,,,,,
427,,,,,,,,,,,,,,
428,,,,,,,,,,,,,,
429,,,,,,,,,,,,,,
430,,,,,,,,,,,,,,
431,,,,,,,,,,,,,,
432,,,,,,,,,,,,,,
433,,,,,,,,,,,,,,
434,,,,,,,,,,,,,,
435,,,,,,,,,,,,,,
436,,,,,,,,,,,,,,
437,,,,,,,,,,,,,,
438,,,,,,,,,,,,,,
439,,,,,,,,,,,,,,
440,,,,,,,,,,,,,,
441,,,,,,,,,,,,,,
442,,,,,,,,,,,,,,
443,,,,,,,,,,,,,,
444,,,,,,,,,,,,,,
445,,,,,,,,,,,,,,
446,,,,,,,,,,,,,,
447,,,,,,,,,,,,,,
448,,,,,,,,,,,,,,
449,,,,,,,,,,,,,,
450,,,,,,,,,,,,,,
451,,,,,,,,,,,,,,
452,,,,,,,,,,,,,,
453,,,,,,,,,,,,,,
454,,,,,,,,,,,,,,
455,,,,,,,,,,,,,,
456,,,,,,,,,,,,,,
457,,,,,,,,,,,,,,
458,,,,,,,,,,,,,,
459,,,,,,,,,,,,,,
460,,,,,,,,,,,,,,
461,,,,,,,,,,,,,,
462,,,,,,,,,,,,,,
463,,,,,,,,,,,,,,
464,,,,,,,,,,,,,,
465,,,,,,,,,,,,,,
466,,,,,,,,,,,,,,
467,,,,,,,,,,,,,,
468,,,,,,,,,,,,,,
469,,,,,,,,,,,,,,
470,,,,,,,,,,,,,,
471,,,,,,,,,,,,,,
472,,,,,,,,,,,,,,
473,,,,,,,,,,,,,,
474,,,,,,,,,,,,,,
475,,,,,,,,,,,,,,
476,,,,,,,,,,,,,,
477,,,,,,,,,,,,,,
478,,,,,,,,,,,,,,
479,,,,,,,,,,,,,,
480,,,,,,,,,,,,,,
481,,,,,,,,,,,,,,
482,,,,,,,,,,,,,,
483,,,,,,,,,,,,,,
484,,,,,,,,,,,,,,
485,,,,,,,,,,,,,,
486,,,,,,,,,,,,,,
487,,,,,,,,,,,,,,
488,,,,,,,,,,,,,,
489,,,,,,,,,,,,,,
490,,,,,,,,,,,,,,
491,,,,,,,,,,,,,,
492,,,,,,,,,,,,,,
493,,,,,,,,,,,,,,
494,,,,,,,,,,,,,,
495,,,,,,,,,,,,,,
496,,,,,,,,,,,,,,
497,,,,,,,,,,,,,,
498,,,,,,,,,,,,,,
499,,,,,,,,,,,,,,
500,,,,,,,,,,,,,,
501,,,,,,,,,,,,,,
502,,,,,,,,,,,,,,
503,,,,,,,,,,,,,,
504,,,,,,,,,,,,,,
505,,,,,,,,,,,,,,
506,,,,,,,,,,,,,,
507,,,,,,,,,,,,,,
508,,,,,,,,,,,,,,
509,,,,,,,,,,,,,,
510,,,,,,,,,,,,,,
511,,,,,,,,,,,,,,
512,,,,,,,,,,,,,,
513,,,,,,,,,,,,,,
514,,,,,,,,,,,,,,
515,,,,,,,,,,,,,,
516,,,,,,,,,,,,,,
517,,,,,,,,,,,,,,
518,,,,,,,,,,,,,,
519,,,,,,,,,,,,,,
520,,,,,,,,,,,,,,
521,,,,,,,,,,,,,,
522,,,,,,,,,,,,,,
523,,,,,,,,,,,,,,
524,,,,,,,,,,,,,,
525,,,,,,,,,,,,,,
526,,,,,,,,,,,,,,
527,,,,,,,,,,,,,,
528,,,,,,,,,,,,,,
529,,,,,,,,,,,,,,
530,,,,,,,,,,,,,,
531,,,,,,,,,,,,,,
532,,,,,,,,,,,,,,
533,,,,,,,,,,,,,,
534,,,,,,,,,,,,,,
535,,,,,,,,,,,,,,
536,,,,,,,,,,,,,,
537,,,,,,,,,,,,,,
538,,,,,,,,,,,,,,
539,,,,,,,,,,,,,,
540,,,,,,,,,,,,,,
541,,,,,,,,,,,,,,
542,,,,,,,,,,,,,,
543,,,,,,,,,,,,,,
544,,,,,,,,,,,,,,
545,,,,,,,,,,,,,,
546,,,,,,,,,,,,,,
547,,,,,,,,,,,,,,
548,,,,,,,,,,,,,,
549,,,,,,,,,,,,,,
550,,,,,,,,,,,,,,
551,,,,,,,,,,,,,,
552,,,,,,,,,,,,,,
553,,,,,,,,,,,,,,
554,,,,,,,,,,,,,,
555,,,,,,,,,,,,,,
556,,,,,,,,,,,,,,
557,,,,,,,,,,,,,,
558,,,,,,,,,,,,,,
559,,,,,,,,,,,,,,
560,,,,,,,,,,,,,,
561,,,,,,,,,,,,,,
562,,,,,,,,,,,,,,
563,,,,,,,,,,,,,,
564,,,,,,,,,,,,,,
565,,,,,,,,,,,,,,
566,,,,,,,,,,,,,,
567,,,,,,,,,,,,,,
568,,,,,,,,,,,,,,
569,,,,,,,,,,,,,,
570,,,,,,,,,,,,,,
571,,,,,,,,,,,,,,
572,,,,,,,,,,,,,,
573,,,,,,,,,,,,,,
574,,,,,,,,,,,,,,
575,,,,,,,,,,,,,,
576,,,,,,,,,,,,,,
577,,,,,,,,,,,,,,
578,,,,,,,,,,,,,,
579,,,,,,,,,,,,,,
580,,,,,,,,,,,,,,
581,,,,,,,,,,,,,,
582,,,,,,,,,,,,,,
583,,,,,,,,,,,,,,
584,,,,,,,,,,,,,,
585,,,,,,,,,,,,,,
586,,,,,,,,,,,,,,
587,,,,,,,,,,,,,,
588,,,,,,,,,,,,,,
589,,,,,,,,,,,,,,
590,,,,,,,,,,,,,,
591,,,,,,,,,,,,,,
592,,,,,,,,,,,,,,
593,,,,,,,,,,,,,,
594,,,,,,,,,,,,,,
595,,,,,,,,,,,,,,
596,,,,,,,,,,,,,,
597,,,,,,,,,,,,,,
598,,,,,,,,,,,,,,
599,,,,,,,,,,,,,,
600,,,,,,,,,,,,,,
601,,,,,,,,,,,,,,
602,,,,,,,,,,,,,,
603,,,,,,,,,,,,,,
604,,,,,,,,,,,,,,
605,,,,,,,,,,,,,,
606,,,,,,,,,,,,,,
607,,,,,,,,,,,,,,
608,,,,,,,,,,,,,,
609,,,,,,,,,,,,,,
610,,,,,,,,,,,,,,
611,,,,,,,,,,,,,,
612,,,,,,,,,,,,,,
613,,,,,,,,,,,,,,
614,,,,,,,,,,,,,,
615,,,,,,,,,,,,,,
616,,,,,,,,,,,,,,
617,,,,,,,,,,,,,,
618,,,,,,,,,,,,,,
619,,,,,,,,,,,,,,
620,,,,,,,,,,,,,,
621,,,,,,,,,,,,,,
622,,,,,,,,,,,,,,
623,,,,,,,,,,,,,,
624,,,,,,,,,,,,,,
625,,,,,,,,,,,,,,
626,,,,,,,,,,,,,,
627,,,,,,,,,,,,,,
628,,,,,,,,,,,,,,
629,,,,,,,,,,,,,,
630,,,,,,,,,,,,,,
631,,,,,,,,,,,,,,
632,,,,,,,,,,,,,,
633,,,,,,,,,,,,,,
634,,,,,,,,,,,,,,
635,,,,,,,,,,,,,,
636,,,,,,,,,,,,,,
637,,,,,,,,,,,,,,
638,,,,,,,,,,,,,,
639,,,,,,,,,,,,,,
640,,,,,,,,,,,,,,
641,,,,,,,,,,,,,,
642,,,,,,,,,,,,,,
643,,,,,,,,,,,,,,
644,,,,,,,,,,,,,,
645,,,,,,,,,,,,,,
646,,,,,,,,,,,,,,
647,,,,,,,,,,,,,,
648,,,,,,,,,,,,,,
649,,,,,,,,,,,,,,
650,,,,,,,,,,,,,,
651,,,,,,,,,,,,,,
652,,,,,,,,,,,,,,
653,,,,,,,,,,,,,,
654,,,,,,,,,,,,,,
655,,,,,,,,,,,,,,
656,,,,,,,,,,,,,,
657,,,,,,,,,,,,,,
658,,,,,,,,,,,,,,
659,,,,,,,,,,,,,,
660,,,,,,,,,,,,,,
661,,,,,,,,,,,,,,
662,,,,,,,,,,,,,,
663,,,,,,,,,,,,,,
664,,,,,,,,,,,,,,
665,,,,,,,,,,,,,,
666,,,,,,,,,,,,,,
667,,,,,,,,,,,,,,
668,,,,,,,,,,,,,,
669,,,,,,,,,,,,,,
670,,,,,,,,,,,,,,
671,,,,,,,,,,,,,,
672,,,,,,,,,,,,,,
673,,,,,,,,,,,,,,
674,,,,,,,,,,,,,,
675,,,,,,,,,,,,,,
676,,,,,,,,,,,,,,
677,,,,,,,,,,,,,,
678,,,,,,,,,,,,,,
679,,,,,,,,,,,,,,
680,,,,,,,,,,,,,,
681,,,,,,,,,,,,,,
682,,,,,,,,,,,,,,
683,,,,,,,,,,,,,,
684,,,,,,,,,,,,,,
685,,,,,,,,,,,,,,
686,,,,,,,,,,,,,,
687,,,,,,,,,,,,,,
688,,,,,,,,,,,,,,
689,,,,,,,,,,,,,,
690,,,,,,,,,,,,,,
691,,,,,,,,,,,,,,
692,,,,,,,,,,,,,,
693,,,,,,,,,,,,,,
694,,,,,,,,,,,,,,
695,,,,,,,,,,,,,,
696,,,,,,,,,,,,,,
697,,,,,,,,,,,,,,
698,,,,,,,,,,,,,,
699,,,,,,,,,,,,,,
700,,,,,,,,,,,,,,
701,,,,,,,,,,,,,,
702,,,,,,,,,,,,,,
703,,,,,,,,,,,,,,
704,,,,,,,,,,,,,,
705,,,,,,,,,,,,,,
706,,,,,,,,,,,,,,
707,,,,,,,,,,,,,,
708,,,,,,,,,,,,,,
709,,,,,,,,,,,,,,
710,,,,,,,,,,,,,,
711,,,,,,,,,,,,,,
712,,,,,,,,,,,,,,
713,,,,,,,,,,,,,,
714,,,,,,,,,,,,,,
715,,,,,,,,,,,,,,
716,,,,,,,,,,,,,,
717,,,,,,,,,,,,,,
718,,,,,,,,,,,,,,
719,,,,,,,,,,,,,,
720,,,,,,,,,,,,,,
721,,,,,,,,,,,,,,
722,,,,,,,,,,,,,,
723,,,,,,,,,,,,,,
724,,,,,,,,,,,,,,
725,,,,,,,,,,,,,,
726,,,,,,,,,,,,,,
727,,,,,,,,,,,,,,
728,,,,,,,,,,,,,,
729,,,,,,,,,,,,,,
730,,,,,,,,,,,,,,
731,,,,,,,,,,,,,,
732,,,,,,,,,,,,,,
733,,,,,,,,,,,,,,
734,,,,,,,,,,,,,,
735,,,,,,,,,,,,,,
736,,,,,,,,,,,,,,
737,,,,,,,,,,,,,,
738,,,,,,,,,,,,,,
739,,,,,,,,,,,,,,
740,,,,,,,,,,,,,,
741,,,,,,,,,,,,,,
742,,,,,,,,,,,,,,
743,,,,,,,,,,,,,,
744,,,,,,,,,,,,,,
745,,,,,,,,,,,,,,
746,,,,,,,,,,,,,,
747,,,,,,,,,,,,,,
748,,,,,,,,,,,,,,
749,,,,,,,,,,,,,,
750,,,,,,,,,,,,,,
751,,,,,,,,,,,,,,
752,,,,,,,,,,,,,,
753,,,,,,,,,,,,,,
754,,,,,,,,,,,,,,
755,,,,,,,,,,,,,,
756,,,,,,,,,,,,,,
757,,,,,,,,,,,,,,
758,,,,,,,,,,,,,,
759,,,,,,,,,,,,,,
760,,,,,,,,,,,,,,
761,,,,,,,,,,,,,,
762,,,,,,,,,,,,,,
763,,,,,,,,,,,,,,
764,,,,,,,,,,,,,,
765,,,,,,,,,,,,,,
766,,,,,,,,,,,,,,
767,,,,,,,,,,,,,,
768,,,,,,,,,,,,,,
769,,,,,,,,,,,,,,
770,,,,,,,,,,,,,,
771,,,,,,,,,,,,,,
772,,,,,,,,,,,,,,
773,,,,,,,,,,,,,,
774,,,,,,,,,,,,,,
775,,,,,,,,,,,,,,
776,,,,,,,,,,,,,,
777,,,,,,,,,,,,,,
778,,,,,,,,,,,,,,
779,,,,,,,,,,,,,,
780,,,,,,,,,,,,,,
781,,,,,,,,,,,,,,
782,,,,,,,,,,,,,,
783,,,,,,,,,,,,,,
784,,,,,,,,,,,,,,
785,,,,,,,,,,,,,,
786,,,,,,,,,,,,,,
787,,,,,,,,,,,,,,
788,,,,,,,,,,,,,,
789,,,,,,,,,,,,,,
790,,,,,,,,,,,,,,
791,,,,,,,,,,,,,,
792,,,,,,,,,,,,,,
793,,,,,,,,,,,,,,
794,,,,,,,,,,,,,,
795,,,,,,,,,,,,,,
796,,,,,,,,,,,,,,
797,,,,,,,,,,,,,,
798,,,,,,,,,,,,,,
799,,,,,,,,,,,,,,
800,,,,,,,,,,,,,,
801,,,,,,,,,,,,,,
802,,,,,,,,,,,,,,
803,,,,,,,,,,,,,,
804,,,,,,,,,,,,,,
805,,,,,,,,,,,,,,
806,,,,,,,,,,,,,,
807,,,,,,,,,,,,,,
808,,,,,,,,,,,,,,
809,,,,,,,,,,,,,,
810,,,,,,,,,,,,,,
811,,,,,,,,,,,,,,
812,,,,,,,,,,,,,,
813,,,,,,,,,,,,,,
814,,,,,,,,,,,,,,
815,,,,,,,,,,,,,,
816,,,,,,,,,,,,,,
817,,,,,,,,,,,,,,
818,,,,,,,,,,,,,,
819,,,,,,,,,,,,,,
820,,,,,,,,,,,,,,
821,,,,,,,,,,,,,,
822,,,,,,,,,,,,,,
823,,,,,,,,,,,,,,
824,,,,,,,,,,,,,,
825,,,,,,,,,,,,,,
826,,,,,,,,,,,,,,
827,,,,,,,,,,,,,,
828,,,,,,,,,,,,,,
829,,,,,,,,,,,,,,
830,,,,,,,,,,,,,,
831,,,,,,,,,,,,,,
832,,,,,,,,,,,,,,
833,,,,,,,,,,,,,,
834,,,,,,,,,,,,,,
835,,,,,,,,,,,,,,
836,,,,,,,,,,,,,,
837,,,,,,,,,,,,,,
838,,,,,,,,,,,,,,
839,,,,,,,,,,,,,,
840,,,,,,,,,,,,,,
841,,,,,,,,,,,,,,
842,,,,,,,,,,,,,,
843,,,,,,,,,,,,,,
844,,,,,,,,,,,,,,
845,,,,,,,,,,,,,,
846,,,,,,,,,,,,,,
847,,,,,,,,,,,,,,
848,,,,,,,,,,,,,,
849,,,,,,,,,,,,,,
850,,,,,,,,,,,,,,
851,,,,,,,,,,,,,,
852,,,,,,,,,,,,,,
853,,,,,,,,,,,,,,
854,,,,,,,,,,,,,,
855,,,,,,,,,,,,,,
856,,,,,,,,,,,,,,
857,,,,,,,,,,,,,,
858,,,,,,,,,,,,,,
859,,,,,,,,,,,,,,
860,,,,,,,,,,,,,,
861,,,,,,,,,,,,,,
862,,,,,,,,,,,,,,
863,,,,,,,,,,,,,,
864,,,,,,,,,,,,,,
865,,,,,,,,,,,,,,
866,,,,,,,,,,,,,,
867,,,,,,,,,,,,,,
868,,,,,,,,,,,,,,
869,,,,,,,,,,,,,,
870,,,,,,,,,,,,,,
871,,,,,,,,,,,,,,
872,,,,,,,,,,,,,,
873,,,,,,,,,,,,,,
874,,,,,,,,,,,,,,
875,,,,,,,,,,,,,,
876,,,,,,,,,,,,,,
877,,,,,,,,,,,,,,
878,,,,,,,,,,,,,,
879,,,,,,,,,,,,,,
880,,,,,,,,,,,,,,
881,,,,,,,,,,,,,,
882,,,,,,,,,,,,,,
883,,,,,,,,,,,,,,
884,,,,,,,,,,,,,,
885,,,,,,,,,,,,,,
886,,,,,,,,,,,,,,
887,,,,,,,,,,,,,,
888,,,,,,,,,,,,,,
889,,,,,,,,,,,,,,
890,,,,,,,,,,,,,,
891,,,,,,,,,,,,,,
892,,,,,,,,,,,,,,
893,,,,,,,,,,,,,,
894,,,,,,,,,,,,,,
895,,,,,,,,,,,,,,
896,,,,,,,,,,,,,,
897,,,,,,,,,,,,,,
898,,,,,,,,,,,,,,
899,,,,,,,,,,,,,,
900,,,,,,,,,,,,,,
901,,,,,,,,,,,,,,
902,,,,,,,,,,,,,,
903,,,,,,,,,,,,,,
904,,,,,,,,,,,,,,
905,,,,,,,,,,,,,,
906,,,,,,,,,,,,,,
907,,,,,,,,,,,,,,
908,,,,,,,,,,,,,,
909,,,,,,,,,,,,,,
910,,,,,,,,,,,,,,
911,,,,,,,,,,,,,,
912,,,,,,,,,,,,,,
913,,,,,,,,,,,,,,
914,,,,,,,,,,,,,,
915,,,,,,,,,,,,,,
916,,,,,,,,,,,,,,
917,,,,,,,,,,,,,,
918,,,,,,,,,,,,,,
919,,,,,,,,,,,,,,
920,,,,,,,,,,,,,,
921,,,,,,,,,,,,,,
922,,,,,,,,,,,,,,
923,,,,,,,,,,,,,,
924,,,,,,,,,,,,,,
925,,,,,,,,,,,,,,
926,,,,,,,,,,,,,,
927,,,,,,,,,,,,,,
928,,,,,,,,,,,,,,
929,,,,,,,,,,,,,,
930,,,,,,,,,,,,,,
931,,,,,,,,,,,,,,
932,,,,,,,,,,,,,,
933,,,,,,,,,,,,,,
934,,,,,,,,,,,,,,
935,,,,,,,,,,,,,,
936,,,,,,,,,,,,,,
937,,,,,,,,,,,,,,
938,,,,,,,,,,,,,,
939,,,,,,,,,,,,,,
940,,,,,,,,,,,,,,
941,,,,,,,,,,,,,,
942,,,,,,,,,,,,,,
943,,,,,,,,,,,,,,
944,,,,,,,,,,,,,,
945,,,,,,,,,,,,,,
946,,,,,,,,,,,,,,
947,,,,,,,,,,,,,,
948,,,,,,,,,,,,,,
949,,,,,,,,,,,,,,
950,,,,,,,,,,,,,,
951,,,,,,,,,,,,,,
952,,,,,,,,,,,,,,
953,,,,,,,,,,,,,,
954,,,,,,,,,,,,,,
955,,,,,,,,,,,,,,
956,,,,,,,,,,,,,,
957,,,,,,,,,,,,,,
958,,,,,,,,,,,,,,
959,,,,,,,,,,,,,,
960,,,,,,,,,,,,,,
961,,,,,,,,,,,,,,
962,,,,,,,,,,,,,,
963,,,,,,,,,,,,,,
964,,,,,,,,,,,,,,
965,,,,,,,,,,,,,,
966,,,,,,,,,,,,,,
967,,,,,,,,,,,,,,
968,,,,,,,,,,,,,,
969,,,,,,,,,,,,,,
970,,,,,,,,,,,,,,
971,,,,,,,,,,,,,,
972,,,,,,,,,,,,,,
973,,,,,,,,,,,,,,
974,,,,,,,,,,,,,,
975,,,,,,,,,,,,,,
976,,,,,,,,,,,,,,
977,,,,,,,,,,,,,,
978,,,,,,,,,,,,,,
979,,,,,,,,,,,,,,
980,,,,,,,,,,,,,,
981,,,,,,,,,,,,,,
982,,,,,,,,,,,,,,
983,,,,,,,,,,,,,,
984,,,,,,,,,,,,,,
985,,,,,,,,,,,,,,
986,,,,,,,,,,,,,,
987,,,,,,,,,,,,,,
988,,,,,,,,,,,,,,
989,,,,,,,,,,,,,,
990,,,,,,,,,,,,,,
991,,,,,,,,,,,,,,
992,,,,,,,,,,,,,,
993,,,,,,,,,,,,,,
994,,,,,,,,,,,,,,
995,,,,,,,,,,,,,,
996,,,,,,,,,,,,,,
997,,,,,,,,,,,,,,
998,,,,,,,,,,,,,,
